---
runtime: shiny
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## PMS Study

This is an interactive, Shiny Rmd file for the PMS study

```{r libraries, include = FALSE}

    
#### Settings & Packages #### -----------------------------------------------------
rm(list = ls())
options(contrasts = c("contr.sum","contr.poly")) #use this for the p value of the t test
library(lme4)
library(lmerTest)
library(effects)
library(dplyr)
library(car)
library(emmeans)
library(fitdistrplus)
library(dplyr)
library(car)
# library(MuMIn)
library(ggplot2)
library(ggstatsplot)
library(ggsignif)
library(ggformula)
library(ggdist)
library(raincloudplots)
library(gridExtra)
library(tidyverse)
library(ggeffects)
library(pander)


library(cowplot)
library(readr)

# library(viridis)
library (yarrr)
library(knitr)
recode <- dplyr::recode
# Suppress summarize info
options(dplyr.summarise.inform = FALSE)
count <- dplyr::count 
# set the theme to theme_bw for all ggplot2 figures
theme_set(theme_bw())
# create folder to save figures
if (!dir.exists("figures")) dir.create("figures")


# General settings
nAGQ = 0 # When writing code, set to 0, when getting final results, set to 1
```


```{r load-data, echo=FALSE, results='asis'}
#### IMPORT DATA & INSPECTION #### -------------------------------------------------------------
knitr::opts_knit$set(root.dir = dirname(rstudioapi::getActiveDocumentContext()$path))# Set working directory to current directory
# setwd("C:\Users\ASUSTeK\OneDrive\2021-2022\internship\projects")
data <- read.csv("Data/allPMSdata.csv", header=TRUE)
# data <- read.table("Data/allPMSdata.csv",sep="\t", header=TRUE)


# from wide to long
#check if subject column is a facctor
#str(data)
#head(data)
# data <-as.numeric(data)
data$Subject <- factor(data$ID)
#typeof(data$Subject)


#we make a new variable that has value 1 for the first TestMoment and 2 for the second TestMoment
#These moments were counterbalanced
#when the order was B-A and the moment is B, this means it is the first test moment
#and vice versa for A-B and moment A. 

# TestMoment 1 == Follicular phase
# TestMoment 2 == Luteal phase
data$TestMoment[data$Order == "A-B" & data$Moment == "A"] = 1
data$TestMoment[data$Order == "B-A" & data$Moment == "A"] = 2
data$TestMoment[data$Order == "A-B" & data$Moment == "B"] = 2
data$TestMoment[data$Order == "B-A" & data$Moment == "B"] = 1
#check if there are still values missing (NA)
#sum(is.na(data$TestMoment))

# new variable PMSSCORE NEW iedereen pms 0 ook 0 iedereen die 1 OF 2 heeft wordt 1, 
data$PMSScoreNew[data$PMSScore==0] = 'noPMS'
data$PMSScoreNew[data$PMSScore==1] = 'PMS'
data$PMSScoreNew[data$PMSScore==2] = 'PMS'
#sum(is.na(data$PMSScoreNew))


# Check whether R recognizes the variable types correctly
#we make factors of the independable variables

data$PMSScore <- factor(data$PMSScore)
data$PMSScoreNew <- factor(data$PMSScoreNew)

data$Moment <- factor(data$TestMoment) # This removes "A and B", A == 1, B == 2 now

# Exclude data?
dataBig = data # Saved all the data here
data = data[, -which(names(data) == "X" | names(data) == "Stimulus" | names(data) == "Valence" | names(data) == "Arousal" | names(data) == "rt")]
data = distinct(data)

# exclude everyone on the pill/copper spiral/other: only those with Natural Contraception are left included
data<-subset(data, Contraception!="Pill" & Contraception!="other" & Contraception!="Cop. Coil" & Contraception!="Hor.Coil")

data <- subset(data,BSRI!=0 ) #remove datapoints where BSRI = 0

# Define the formula for the model & check which model fits the data best

data_temp <- data #to get back to



  # violin function

    geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                                 position = "dodge", trim = TRUE, scale = "area",
                                 show.legend = NA, inherit.aes = TRUE, ...) {
      layer(
      data = data,
      mapping = mapping,
      stat = stat,
      geom = GeomFlatViolin,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = list(
        trim = trim,
        scale = scale,
        ...
     )
    )
  }

```


```{r echo=FALSE}

```
## 



```{r echo=FALSE}
library(shiny)


ui<- fluidPage( # makes the User Interface
  sidebarPanel(
    selectInput("formula_choice", label="Choose a Formula:",
            choices= c('PSS ~ TestMoment', 'BSRI ~ TestMoment', 'PSS~ PMSScoreNew*TestMoment', 'BSRI ~PMSScoreNew*TestMoment'),
            selected='PSS ~ TestMoment'), # puts the choices in the first element which is accessed via input$formula_choice
  ),
  mainPanel(
     tabsetPanel(type = "tab",
                  tabPanel("pirateplot", plotOutput("pirateplot")),
                 tabPanel("raincloud", plotOutput("raincloud")),
                 tabPanel("AIC table", tableOutput("table")),
                 tabPanel("Anova", verbatimTextOutput("Anova")),
                 tabPanel("emmeans",verbatimTextOutput("emmeans"))
         )
  )
)

server <- function (input, output){ #we have to add this to the server
  
  
  output$pirateplot<- renderPlot({ 
      dpi=600    #pixels per square inch
    # jpeg(paste0(plotPrefix, "Figure", "_", plotTitles[i], ".jpeg"), width=8*dpi, height=4*dpi, res=dpi)
    par(mfcol = c(1, 1))
      pirateplot(
      formula= input$formula_choice,
      data=data,
      theme= 1,
      pal= "info",
      main= input$formula_choice,
      bean.f.o = .6, # Bean fill
      point.o = .3,  # Points
      inf.f.o = .7,  # Inference fill
      inf.b.o = .8,  # Inference border
      avg.line.o = 1,  # Average line
      bar.f.o = .5, # Bar
      inf.f.col = "white",  # Inf fill col
      inf.b.col = "black",  # Inf border col
      avg.line.col = "black",  # avg line col
      bar.f.col = gray(.8),  # bar filling color
      point.pch = 21,
      point.bg = "white",
      point.col = "black",
      point.cex = .7,
      xlab="",
    )

  })

  #https://wellcomeopenresearch.org/articles/4-63
  
  output$raincloud <- renderPlot({
      p1 <- ggplot(data, aes(x = PMSScoreNew, y = PSS, fill=PMSScoreNew))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        ylab('PSS')+xlab('PMSScoreNew')+coord_flip()+theme_cowplot()+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("effect PMS on PSS")
      
      p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill=PMSScoreNew))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        ylab('BSRI')+xlab('PMSScoreNew')+coord_flip()+theme_cowplot()+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("effect PMS on BSRI")
      gridExtra::grid.arrange(p1, p2, ncol=1)
  })

  output$table <- renderTable ({
    Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
    tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
     # chosenModel = modelNames[which(tabel == min(tabel))]
  })
  
  
  output$Anova <- renderPrint({
        Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
    tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
     chosenModel = modelNames[which(tabel == min(tabel))]
     Anova_1 <- Anova(chosenModel[[1]])
     cat(sprintf("\nAnova\n"))
     print(summary(Anova_1))

  })
  
  output$emmeans <- renderPrint({
            Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)

    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)

    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)

    modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
    tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
    chosenModel = modelNames[which(tabel == min(tabel))]
    
    # cat(sprintf("\n %s ~TestMoment\n", gsub("~.*","",input$formula_choice)))
    # Emm <- emmeans(chosenModel[[1]], pairwise ~  TestMoment, adjust ="fdr", type="response")
    # print(Emm)
    # 
    cat(sprintf("\n formula: %s\n", input$formula_choice))
    
    # check <- function (x){
    #   if (gsub(".*~", "", x)=="~TestMoment"){
    #   result <- TestMoment}
    # if (gsub(".*~", "", x)=="~PMSScoreNew*TestMoment"){
    #   result <- PMSScoreNew*TestMoment}
    # 
    
    if ((grepl("PMS", input$formula_choice)==FALSE)){
      cat(sprintf("\n~ TestMoment\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ TestMoment, adjust ="fdr", type="response")
      print(Emm)
    }

    
    if (grepl("PMS", input$formula_choice)){
      cat(sprintf("\n~ PMS*TestMoment\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
      print(Emm)
    }
    




  })
}




shinyApp(ui=ui, server=server)

```

TO DO:


-raincoud plots
-dan: significantie op de afbeeldingen tonen? (dit gaat hacky zijn om te programmeren)
https://stackoverflow.com/questions/17084566/put-stars-on-ggplot-barplots-and-boxplots-to-indicate-the-level-of-significanc


-add info in file over PMS en welke databewerkingen je hebt gedaan
-verderwerken hypotheses (zie hieronder)




############ Hyptothesen en onderzoeksvragen:
PMS vs noPMS op het gebied van:
- PSS
- BSRI

++ Interactie testmoment

PMS vs noPMS voor:
- DASS_alle subschalen
-- Hoeft niet x testmoment


------- Voor de stimuli -----------
Eerste stap:
- Bekijken Valence en arousal tussen de groepen en testmomenten, over alle stimuli als een geheel

Next:
- Per stimulus gemiddelden plotten
-- Om erachter te komen of er coherent geantwoord wordt
-- Om te zien of ze niet te veel van elkaar afwijken
--- waarchuwing; ze gaan veel van elkaar afwijken. 


Stimuli onderverdelen in negatief, positief en neutral, om daar een subdivisie analyse op te maken
*noot: iaos images, ze zijn getagged (zoek op om ze te kunnen onderverdelen). 22, gematched (dus bv naald in arm vs naald in been)

---------------- Overig:
Normgroepen opzoeken voor PSS bij (jonge) vrouwen
https://www.cambridge.org/core/journals/spanish-journal-of-psychology/article/abs/perceived-stress-scale-pss-normative-data-and-factor-structure-for-a-largescale-sample-in-mexico/752B62D15A932A2D148D04376E949F67

https://bmcpsychiatry.biomedcentral.com/articles/10.1186/s12888-016-0875-9/tables/6




---
runtime: shiny
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# PMS Study

This is an interactive, Shiny Rmd file for the PMS study

```{r libraries, include = FALSE}

    
#### Settings & Packages #### -----------------------------------------------------
rm(list = ls())
options(contrasts = c("contr.sum","contr.poly")) #use this for the p value of the t test
library(lme4)
library(lmerTest)
library(effects)
library(dplyr)
library(car)
library(emmeans)
library(fitdistrplus)
library(dplyr)
library(car)
# library(MuMIn)
library(ggplot2)
library(ggstatsplot)
library(ggsignif)
library(ggformula)
library(ggdist)
library(raincloudplots)
library(gridExtra)
library(tidyverse)
library(ggeffects)
library(pander)


library(cowplot)
library(lavaan)
library(readr)
library(jpeg)
library(ggpubr)
library(shiny)
library(raincloudplots)

# library(viridis)
library (yarrr)
library(knitr)
recode <- dplyr::recode
# Suppress summarize info
options(dplyr.summarise.inform = FALSE)
count <- dplyr::count 
# set the theme to theme_bw for all ggplot2 figures
theme_set(theme_bw())
# create folder to save figures
if (!dir.exists("figures")) dir.create("figures")


# General settings
nAGQ = 0 # When writing code, set to 0, when getting final results, set to 1
```


```{r load-data, echo=FALSE, results='asis'}
#### IMPORT data & INSPECTION #### -------------------------------------------------------------
knitr::opts_knit$set(root.dir = dirname(rstudioapi::getActiveDocumentContext()$path))# Set working directory to current directory
#data <-read.csv("C::/Downloads/allPMSdata.csv",header=TRUE)
#setwd("C::/Users/ASUSTeK/OneDrive/Documenten/GitHub/internship_sofie")
data <- read.csv("Data/allPMSdata.csv", header=TRUE)
#IMPORTANT! when not online it will go to Onedrive/documenten, so put Data/allPMS there as well
# data <- read.table("Data/allPMSdata.csv", header=TRUE)


# from wide to long
#check if subject column is a facctor
#str(data)
#head(data)
# data <-as.numeric(data)
data$Subject <- factor(data$ID)
#typeof(data$Subject)


#we make a new variable that has value 1 for the first TestMoment and 2 for the second TestMoment
#These moments were counterbalanced
#when the order was B-A and the moment is B, this means it is the first test moment
#and vice versa for A-B and moment A. 

# TestMoment 1 == Follicular phase
# TestMoment 2 == Luteal phase
data$TestMoment[data$Order == "A-B" & data$Moment == "A"] = 1
data$TestMoment[data$Order == "B-A" & data$Moment == "A"] = 2
data$TestMoment[data$Order == "A-B" & data$Moment == "B"] = 2
data$TestMoment[data$Order == "B-A" & data$Moment == "B"] = 1
#check if there are still values missing (NA)
#sum(is.na(data$TestMoment))

# new variable PMSSCORE NEW iedereen pms 0 ook 0 iedereen die 1 OF 2 heeft wordt 1, 
data$PMSScoreNew[data$PMSScore==0] = 'noPMS'
data$PMSScoreNew[data$PMSScore==1] = 'PMS'
data$PMSScoreNew[data$PMSScore==2] = 'PMS' #PMDD, mr niet officiÃ«le diagnose dus gewoon PMS
#sum(is.na(data$PMSScoreNew))


# Check whether R recognizes the variable types correctly
#we make factors of the independable variables

data$PMSScore <- factor(data$PMSScore)
data$PMSScoreNew <- factor(data$PMSScoreNew)

data$Moment <- factor(data$TestMoment) # This removes "A and B", A == 1, B == 2 now

# Exclude data?
dataBig = data # Saved all the data here
data = data[, -which(names(data) == "X" | names(data) == "Stimulus" | names(data) == "Valence" | names(data) == "Arousal" | names(data) == "rt")] #removes these columns
data= distinct(data)

# exclude everyone on the pill/copper spiral/other: only those with Natural Contraception are left included
data<-subset(data, Contraception!="Pill" & Contraception!="other" & Contraception!="Cop. Coil" & Contraception!="Hor.Coil")

data <- subset(data,BSRI!=0 ) #remove datapoints where BSRI = 0

# Define the formula for the model & check which model fits the data best

data_temp <- data #to get back to



  # violin function

    geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                                 position = "dodge", trim = TRUE, scale = "area",
                                 show.legend = NA, inherit.aes = TRUE, ...) {
      layer(
      data = data,
      mapping = mapping,
      stat = stat,
      geom = GeomFlatViolin,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = list(
        trim = trim,
        scale = scale,
        ...
     )
    )
    }
    
    #standard error function
    standard_error <- function(x) sd(x)/sqrt(length(x))
    
    
    


```


```{r echo=FALSE}

```


## PMS, TestMoment, PSS and BSRI

* #### PMS: 
three groups originally: low and high PMS and what counts as ... on the questionnaire. 
These two last groups were taken together to form the 'no PMS' and 'PMS' groups

* #### TestMoment: 
there are two testmoments, 1 and 2. 1 stands for follicular phase, 2 for mid-luteal phase. 
these testmoments were counterbalanced across participants

!["Image Source: https://helloclue.com/articles/cycle-a-z/the-menstrual-cycle-more-than-just-the-period"](figures/MC.png){width=80%}

* #### PSS
Perceived Stress Scale


* #### BSRI:
Bem Sex Role Inventory
questionnaire with 2 subscales: 
1. masculinity
2. femininity
scores on 1_7 scale (4=middle)
above median score on both scales= 'androgynous'

https://www.psytoolkit.org/survey-library/sex-role-bem.html


### onderzoeksvraag: PMS vs noPMS op het gebied van:
- PSS
- BSRI
+ Interactie testmoment

```{r}

```


```{r echo=FALSE}


ui<- fluidPage( # makes the User Interface
  sidebarPanel(
    selectInput("formula_choice", label="Choose a Formula:",
            choices= c('PSS ~ TestMoment', 'BSRI ~ TestMoment', 'PSS~ PMSScoreNew*TestMoment', 'BSRI ~PMSScoreNew*TestMoment'),
            selected='PSS ~ TestMoment'), # puts the choices in the first element which is accessed via input$formula_choice
  ),
  mainPanel(
     tabsetPanel(type = "tab",
                  tabPanel("pirateplot", plotOutput("pirateplot")),
                 tabPanel("raincloud", plotOutput("raincloud")),
                 tabPanel("raincloud2", plotOutput("raincloud2")),
                 tabPanel("AIC table", tableOutput("table")),
                 tabPanel("Anova", verbatimTextOutput("Anova")),
                 tabPanel("emmeans",verbatimTextOutput("emmeans")),
                 tabPanel("density",plotOutput("density"))
         )
  )
)

server <- function (input, output){ #we have to add this to the server
  
  
  output$pirateplot<- renderPlot({ 
      dpi=600    #pixels per square inch
    # jpeg(paste0(plotPrefix, "Figure", "_", plotTitles[i], ".jpeg"), width=8*dpi, height=4*dpi, res=dpi)
    par(mfcol = c(1, 1))
      pirateplot(
      formula= input$formula_choice,
      data=data,
      theme= 1,
      pal= "info",
      main= input$formula_choice,
      bean.f.o = .6, # Bean fill
      point.o = .3,  # Points
      inf.f.o = .7,  # Inference fill
      inf.b.o = .8,  # Inference border
      avg.line.o = 1,  # Average line
      bar.f.o = .5, # Bar
      inf.f.col = "white",  # Inf fill col
      inf.b.col = "black",  # Inf border col
      avg.line.col = "black",  # avg line col
      bar.f.col = gray(.8),  # bar filling color
      point.pch = 21,
      point.bg = "white",
      point.col = "black",
      point.cex = .7,
      xlab="",
    )

  })

  #https://wellcomeopenresearch.org/articles/4-63   some info on rainclouds
  
  output$raincloud <- renderPlot({
    if ((grepl("PSS", input$formula_choice))){
      p1 <- ggplot(data, aes(x = PMSScoreNew, y = PSS, fill=PMSScoreNew))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        geom_boxplot(width= .15, outlier.shape = NA)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        ylab('PSS')+xlab('PMSScoreNew')+coord_flip()+theme_cowplot()+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("distribution PSS in PMS vs no PMS")
      p1
    }else{
      p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill=PMSScoreNew))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        ylab('BSRI')+xlab('PMSScoreNew')+coord_flip()+theme_cowplot()+
        geom_boxplot(width= .15, outlier.shape = NA)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("distribution BSRI in PMS vs no PMS")
      p2
    }
  })
  
  # https://www.rpubs.com/jenrichmond/W6LL  here some info on the following plot
    output$raincloud2 <- renderPlot({
      
      #function for weighted average
      x1 <- c(2, 4, 7)
      weighted_mean <- 0
      for (i in 1:length(x1)){
       weighted_mean <- (x1[i]+ x1[i+1] + x1[i+2])/3
       print (weighted_mean)
      }

      if ((grepl("PSS", input$formula_choice))){
      
        #dataframe for connected rainclouds
        dataf<- data
        head(dataf)
        # we create a dataframe with only PMSScoreNew and PSS
        require(reshape2)
        dataf<- melt(dataf, id=c("TestMoment", "PSS")) #takes out these 2 variables
        head(dataf)

        #sort by TestMoment ascending (so moment 2 is last)
        dataf <- dataf[order(dataf$TestMoment),]
        head(dataf)
        tail(dataf)
        
        
        df <-data_1x1(
          array_1= dataf$PSS[1:length(dataf$PSS)/2],
          array_2=dataf$PSS[(length(dataf$PSS)/2)+1:length(dataf$PSS)],
          jit_distance=0.09,
          jit_seed=321)
        
        raincloud_2<-raincloud_1x1_repmes(
          data= df,
          colors= (c('dodgerblue', 'darkorange')),
          fills= (c('dodgerblue', 'darkorange')),
          line_color="gray",
          line_alpha=.3,
          size=1,
          alpha= .6,
          align_clouds=FALSE
          #ort='h'
          )+
          scale_x_continuous (breaks=c(1,2), labels=c("1", "2"), limits=c(0,3))+
          xlab("TestMoment")+
          ylab("PSS")+
          theme_classic()
  
        raincloud_2
      } 
      else if ((grepl("BSRI", input$formula_choice))){
         #dataframe for connected rainclouds
        dataf<- data
        head(dataf)
        # we create a dataframe with only PMSScoreNew and PSS
        require(reshape2)
        dataf<- melt(dataf, id=c("TestMoment", "BSRI")) #takes out these 2 variables
        head(dataf)

        #sort by TestMoment ascending (so moment 2 is last)
        dataf <- dataf[order(dataf$TestMoment),]
        head(dataf)
        tail(dataf)
        
        
        df <-data_1x1(
          array_1= dataf$BSRI[1:length(dataf$BSRI)/2],
          array_2=dataf$BSRI[(length(dataf$BSRI)/2)+1:length(dataf$BSRI)],
          jit_distance=0.09,
          jit_seed=321)
        
        raincloud_2<-raincloud_1x1_repmes(
          data= df,
          colors= (c('dodgerblue', 'darkorange')),
          fills= (c('dodgerblue', 'darkorange')),
          line_color="gray",
          line_alpha=.3,
          size=1,
          alpha= .6,
          align_clouds=FALSE
          #ort='h'
          )+
          scale_x_continuous (breaks=c(1,2), labels=c("1", "2"), limits=c(0,3))+
          xlab("TestMoment")+
          ylab("BSRI")+
          theme_classic()
  
        raincloud_2
      }
      
    })
      

  output$table <- renderTable ({
    Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    modelNames= c('d0.1','d0.2','d0.3','d0.4','d0.5','d0.6','d0.7','d0.8','d0.9')
    tabel <-round(cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9)), digits=2)
    chosenModel = modelNames[which(tabel == min(tabel))]
    tabel <- data.frame(Models=c('chosen  Model:','d0.1','d0.2','d0.3','d0.4','d0.5','d0.6','d0.7','d0.8','d0.9'), AIC= c(cbind(chosenModel, tabel)))
    tabel

  })
  
  
  output$Anova <- renderPrint({
        Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
    tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
     chosenModel = modelNames[which(tabel == min(tabel))]
     Anova_1 <- Anova(chosenModel[[1]])
     cat(sprintf("\nAnova\n"))
     Anova_1

  })
  
  output$emmeans <- renderPrint({
            Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)

    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)

    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)

    modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
    tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
    chosenModel = modelNames[which(tabel == min(tabel))]
    
    # cat(sprintf("\n %s ~TestMoment\n", gsub("~.*","",input$formula_choice)))
    # Emm <- emmeans(chosenModel[[1]], pairwise ~  TestMoment, adjust ="fdr", type="response")
    # print(Emm)
    # 
    cat(sprintf("\n formula: %s\n", input$formula_choice))
    
    # check <- function (x){
    #   if (gsub(".*~", "", x)=="~TestMoment"){
    #   result <- TestMoment}
    # if (gsub(".*~", "", x)=="~PMSScoreNew*TestMoment"){
    #   result <- PMSScoreNew*TestMoment}
    # 
    
    if ((grepl("PMS", input$formula_choice)==FALSE)){
      cat(sprintf("\n~ TestMoment\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ TestMoment, adjust ="fdr", type="response")
      print(Emm)
    }
    if (grepl("PMS", input$formula_choice)){
      cat(sprintf("\n~ PMS*TestMoment\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
      print(Emm)
    }
  })
  
  
  output$density <- renderPlot({
      if ((grepl("PSS", input$formula_choice))){
      p1 <- ggplot(data, aes(x = PMSScoreNew, y = PSS, fill = PMSScoreNew)) +
        # geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        geom_flat_violin(aes(fill = PMSScoreNew),position = position_nudge(x = .2, y = 0), adjust = 1.5, trim = FALSE, alpha = .5, colour = NA)+
      geom_point(aes(x = as.numeric(PMSScoreNew)-.15, y = PSS, colour = PMSScoreNew),position = position_jitter(width = .05), size = .20, shape = 20)+
      geom_boxplot(aes(x = PMSScoreNew, y = PSS, fill = PMSScoreNew),outlier.shape = NA, alpha = .5, width = .1, colour = "black")+
      # geom_line(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = mean(PSS), group = PMSScoreNew, colour = PMSScoreNew), linetype = 3)+
      geom_point(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = mean(PSS), group = PMSScoreNew, colour = PMSScoreNew), shape = 18) +
      geom_errorbar(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = PSS, group = PMSScoreNew, colour = PMSScoreNew, ymin = mean(PSS)-standard_error(PSS), ymax = mean(PSS)+standard_error(PSS)), width = .10, length= .20)+
      scale_colour_brewer(palette = "Dark2")+
      scale_fill_brewer(palette = "Dark2")+
      ggtitle("Figure: Repeated Measures - Factorial (Extended)")
      p1
      
      } else {
        
      p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill = PMSScoreNew)) +
        # geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        geom_flat_violin(aes(fill = PMSScoreNew),position = position_nudge(x = .2, y = 0), adjust = 1.5, trim = FALSE, alpha = .5, colour = NA)+
      geom_point(aes(x = as.numeric(PMSScoreNew)-.15, y = BSRI, colour = PMSScoreNew),position = position_jitter(width = .05), size = .20, shape = 20)+
      geom_boxplot(aes(x = PMSScoreNew, y = BSRI, fill = PMSScoreNew),outlier.shape = NA, alpha = .5, width = .1, colour = "black")+
      # geom_line(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = mean(PSS), group = PMSScoreNew, colour = PMSScoreNew), linetype = 3)+
      geom_point(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = mean(BSRI), group = PMSScoreNew, colour = PMSScoreNew), shape = 18) +
      geom_errorbar(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = BSRI, group = PMSScoreNew, colour = PMSScoreNew, ymin = mean(BSRI)-standard_error(BSRI), ymax = mean(BSRI)+standard_error(BSRI)), width = .10, length= .20)+
      scale_colour_brewer(palette = "Dark2")+
      scale_fill_brewer(palette = "Dark2")+
      ggtitle("Figure: Repeated Measures - Factorial (Extended)")
      p2  
      }
  })

}

#knitr::opts_knit$set(/Users/ASUSTeK/OneDrive/Documenten/GitHub/internship_sofie)

shinyApp(ui=ui, server=server)



```
we do (G)LMM: generalized linear mixed models
stress(PSS) or gender(BSRI) as dependable variable
PMS(2 levels) x TestMoment (2 levels)

AIC: Akaike Information Criterion: says which model best (lowest AIC) om beste fit model te vinden.

### conclusions

=> PSS is higher in testmoment 2: luteal phase
sign effect of PMS on PSS
no sign difference between testmoment 1 and 2 with the PMS group!


=>gender difference of PMS vs no PMS: PMS group more 'androgynous'
BSRI is higher in PMS than in noPMS group
-no effect of testmoment on BSRI


## DASS

* #### DASS-21_R
Depression Anxiety Stress Scale
DASS: 3 subschalen
DASS_Total, DASS_Stress, DASS_Anxiety, DASS_Depression
effect of PMS vs no PMSS
-geen interactie want het is trait: mr 1 afname
-wel interactie PSS: trait vs state?

#### onderzoeksvraag: PMS vs noPMS voor:
- DASS_alle subschalen
+interactie PSS



```{r echo=FALSE}

ui<- fluidPage( # makes the User Interface
  sidebarPanel(
    selectInput("formula_choice", label="Choose a Formula:",
            choices= c('DASS_Stress ~ PMSScoreNew', 'DASS_Anxiety ~ PMSScoreNew', 'DASS_Depression ~ PMSScoreNew', 'DASS_Stress ~ PMSScoreNew * PSS', 'DASS_Anxiety ~ PMSScoreNew * PSS', 'DASS_Depression ~ PMSScoreNew * PSS'),
            selected='DASS_Stress ~ PMSScoreNew'), # puts the choices in the first element which is accessed via input$formula_choice
  ),
  

  mainPanel(
     tabsetPanel(type = "tab",
                  tabPanel("pirateplot", plotOutput("pirateplot")),
                  tabPanel("raincloud", plotOutput("raincloud")),
                 tabPanel("raincloud2", plotOutput("raincloud2")),
                 tabPanel("AIC table", tableOutput("table")),
                 tabPanel("Anova", verbatimTextOutput("Anova")),
                 tabPanel("emmeans",verbatimTextOutput("emmeans")),
                 tabPanel("density",
                          fluidRow(
                            splitLayout(style="border: 1px solid silver:", cellWidths=c(300,200,100),
                                        plotOutput("plotgraph1"),
                                        plotOutput("plotgraph2"))
                          )
                          )
         )
  )
)

server <- function (input, output){ #we have to add this to the server


  output$pirateplot<- renderPlot({
      dpi=600    #pixels per square inch
    # jpeg(paste0(plotPrefix, "Figure", "_", plotTitles[i], ".jpeg"), width=8*dpi, height=4*dpi, res=dpi)
    par(mfcol = c(1, 1))
      pirateplot(
      formula= input$formula_choice,
      data=data,
      theme= 1,
      pal= "info",
      main= input$formula_choice,
      bean.f.o = .6, # Bean fill
      point.o = .3,  # Points
      inf.f.o = .7,  # Inference fill
      inf.b.o = .8,  # Inference border
      avg.line.o = 1,  # Average line
      bar.f.o = .5, # Bar
      inf.f.col = "white",  # Inf fill col
      inf.b.col = "black",  # Inf border col
      avg.line.col = "black",  # avg line col
      bar.f.col = gray(.8),  # bar filling color
      point.pch = 21,
      point.bg = "white",
      point.col = "black",
      point.cex = .7,
      xlab="",
    )
  })

  #https://wellcomeopenresearch.org/articles/4-63   some info on rainclouds
  

  #PMS vs noPMS over 2 fases Testmoment, https://github.com/jorvlan/raincloudplots
  
    output$raincloud <- renderPlot({
      if ((grepl("Stress", input$formula_choice))){
        p1 <- ggplot(data, aes(x = PMSScoreNew, y = PSS, fill=PMSScoreNew))+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          geom_boxplot(width= .15, outlier.shape = NA)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Stress in PMS vs no PMS")
        p1
      }else if ((grepl("Anxiety", input$formula_choice))){
        p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill=PMSScoreNew))+
          geom_boxplot(width= .15, outlier.shape = NA)+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Anxiety in PMS vs no PMS")
        p2
      }else {
        p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill=PMSScoreNew))+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          #geom_boxplot(width= .15, outlier.shape = NA)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Depression in PMS vs no PMS")
        p2
      }
    })

  output$table <- renderTable ({
    modelNames <- c() #empty
    models <-c()
    # Formula <- 'DASS_Stress ~ PMSScoreNew + (1|Subject)'
    Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    
    an.error.occured <- FALSE# then we set this to false
    tryCatch(
      { d0.1 <- lmer(Formula,data=data); print(result) }, # if this formula works, we return it
      error=function(e){an.error.occured <<-TRUE} # if it doesn't, then we set this to true
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.1')}
    if (an.error.occured==FALSE) {models <-c(models,d0.1)} # if formula works, add this to the modeNames array
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.2')}
    if (an.error.occured==FALSE) { models <-c(models,d0.2)}
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.3')}
    if (an.error.occured==FALSE) { models <-c(models,d0.3)}
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.4')}
    if (an.error.occured==FALSE) { models <-c(models,d0.4)}
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.5')}
    if (an.error.occured==FALSE) { models <-c(models,d0.5)}
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.6')}
    if (an.error.occured==FALSE) { models <-c(models,d0.6)}
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.7')}
    if (an.error.occured==FALSE) { models <-c(models,d0.7)}
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.8')}
    if (an.error.occured==FALSE) { models <-c(models,d0.8)}
    
    an.error.occured <- FALSE
    tryCatch(
      { d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
      error=function(e){an.error.occured <<-TRUE}
    )
    if (an.error.occured==FALSE) {modelNames <-c(modelNames, 'd0.9')}
    if (an.error.occured==FALSE) { models <-c(models,d0.9)}
    
    # This is a function to determine whether there is an error or not. 
    
    # an.error.occured <- FALSE
    # tryCatch(
    #   { d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); print(result) },
    #   error=function(e){an.error.occured <<-TRUE}
    # )
    # print(an.error.occured)
    #   
    # })
    tabel <- c()
    for (i in 1:length(models)){
      AIC<- AIC(models[[i]])
      tabel <- c(tabel,round(cbind(AIC)))
    }
    tabel
      
      
    chosenModel = modelNames[which(tabel == min(tabel))]
    tabel <- data.frame(Models=c('chosen  Model:', modelNames), AIC= c(chosenModel, tabel))
    tabel

  })
  # 
  # 
  # output$Anova <- renderPrint({
  #       Formula <- paste0(input$formula_choice, ' + (1|Subject)')
  #   d0.1 <- lmer(Formula,data=data)
  #   d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  #   d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  # 
  #   d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  #   d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  #   d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  # 
  #   d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  #   d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  #   d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  # 
  #   modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
  #   tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
  #    chosenModel = modelNames[which(tabel == min(tabel))]
  #    Anova_1 <- Anova(chosenModel[[1]])
  #    cat(sprintf("\nAnova\n"))
  #    Anova_1
  # 
  # })
#   # 
#   # output$emmeans <- renderPrint({
#   #           Formula <- paste0(input$formula_choice, ' + (1|Subject)')
#   #   d0.1 <- lmer(Formula,data=data)
#   #   d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   #   d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   # 
#   #   d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   #   d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   #   d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   # 
#   #   d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   #   d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   #   d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
#   # 
#   #   modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
#   #   tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
#   #   chosenModel = modelNames[which(tabel == min(tabel))]
#   #   
#   #   # cat(sprintf("\n %s ~TestMoment\n", gsub("~.*","",input$formula_choice)))
#   #   # Emm <- emmeans(chosenModel[[1]], pairwise ~  TestMoment, adjust ="fdr", type="response")
#   #   # print(Emm)
#   #   # 
#   #   cat(sprintf("\n formula: %s\n", input$formula_choice))
#   #   
#   #   # check <- function (x){
#   #   #   if (gsub(".*~", "", x)=="~TestMoment"){
#   #   #   result <- TestMoment}
#   #   # if (gsub(".*~", "", x)=="~PMSScoreNew*TestMoment"){
#   #   #   result <- PMSScoreNew*TestMoment}
#   #   # 
#   #   
#   #   if ((grepl("PMS", input$formula_choice)==FALSE)){
#   #     cat(sprintf("\n~ TestMoment\n"))
#   #     Emm <- emmeans(chosenModel[[1]], pairwise ~ TestMoment, adjust ="fdr", type="response")
#   #     print(Emm)
#   #   }
#   #   if (grepl("PMS", input$formula_choice)){
#   #     cat(sprintf("\n~ PMS*TestMoment\n"))
#   #     Emm <- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
#   #     print(Emm)
#   #   }
#   # })
#   # 
#   # 
#   # output$normality <-renderPrint({
#   #   cat(sprintf("\n shapiro normality test. if p <.05: not-normal distribution\n"))
#   #   if((grepl("PSS", input$formula_choice))){
#   #     print(shapiro.test(data$PSS))
#   #   } else {
#   #     print(shapiro.test(data$BSRI))
#   #   } # no for loop because we want to try this feature of having two figures next to each other (look at ui part)
#   # })
#   # 
#   # output$plotgraph1 <- renderPlot({
#   #   ggdensity(data$PSS, xlab="PSS" )
#   # })
#   # output$plotgraph2 <- renderPlot({
#   #   ggdensity(data$BSRI, xlab="BSRI")
#   # })
}


shinyApp(ui=ui, server=server)

```




# Hyptothesen en onderzoeksvragen:



## Voor de stimuli 
### Eerste stap:
- Bekijken Valence en arousal tussen de groepen en testmomenten, over alle stimuli als een geheel

### Next:
- Per stimulus gemiddelden plotten
-- Om erachter te komen of er coherent geantwoord wordt
-- Om te zien of ze niet te veel van elkaar afwijken
--- waarchuwing; ze gaan veel van elkaar afwijken. 


Stimuli onderverdelen in negatief, positief en neutral, om daar een subdivisie analyse op te maken
*noot: iaos images, ze zijn getagged (zoek op om ze te kunnen onderverdelen). 22, gematched (dus bv naald in arm vs naald in been)

### Overig:
Normgroepen opzoeken voor PSS bij (jonge) vrouwen
https://www.cambridge.org/core/journals/spanish-journal-of-psychology/article/abs/perceived-stress-scale-pss-normative-data-and-factor-structure-for-a-largescale-sample-in-mexico/752B62D15A932A2D148D04376E949F67

https://bmcpsychiatry.biomedcentral.com/articles/10.1186/s12888-016-0875-9/tables/6


TO DO:

-raincloud plot visueel aantrekkelijker
-plots, anova etc DASS toevoegen


-variabelen steekproef in beeld (puur omdat  interessant: PMS vs no PMS: leeftijd, duur cyclus (gemm))

-stimuli plotten, outliers eruit 

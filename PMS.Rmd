---
title: "PMS STUDY"
author: "Mitchel Kappen & Sofie Raeymakers"
date: "`r Sys.setlocale('LC_TIME', 'C'); format(Sys.time(), '%d\\\\. %B %Y')`"
runtime: shiny
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# PMS Study {.tabset}

This is an interactive, Shiny Rmd file for the PMS study

```{r libraries, include = FALSE}
#### Settings & Packages #### -----------------------------------------------------
rm(list = ls())
#install packages
list.of.packages <- c("lme4",'lmerTest','effects','dplyr', 'car', 'Rmisc', 'emmeans','fitdistrplus','ggplot2', 'ggstatsplot','ggsignif', 'ggformula','ggdist','ggpubr','ggeffects', 'gplots', 'gridExtra','tidyverse','pander','stringr','cowplot','lavaan','readr','jpeg','shiny','reshape2', 'yarrr','knitr', 'remotes', 'raincloudplots')
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

library(Rmisc)
library(raincloudplots)
library(lme4)
library(lmerTest)
library(effects)
library(dplyr)
library(car)
library(emmeans)
library(fitdistrplus)
library(gplots)
library(ggplot2)
library(ggstatsplot)
library(ggsignif)
library(ggformula)
library(ggdist)
library(ggpubr)
library(ggeffects)
library(gridExtra)
library(tidyverse)
library(pander)
library(stringr)
library(cowplot)
library(lavaan)
library(readr)
library(jpeg)
library(shiny)
library(reshape2)
library (yarrr)
library(knitr)
library(remotes)
recode <- dplyr::recode
count <- dplyr::count 

# create folder to save figures
if (!dir.exists("figures")) dir.create("figures")
# General settings
nAGQ = 0 # When writing code, set to 0, when getting final results, set to 1ù
vpn = 1 # Set to 1 if using VPN
```

```{r load-data, echo=FALSE}
#### IMPORT data & INSPECTION #### -------------------------------------------------------------
#data directly from VPN folder
# work_dir<-"Z:\\shares\\ghepmk_data\\2020_Kappen_PMS\\RMarkdown\\Data\\"
# setwd(work_dir)
# setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
if (vpn == 1){
  Dir = "Z:\\shares\\ghepmk_data\\2020_Kappen_PMS\\RMarkdown\\" #data from VPN folder
} else {
  Dir = "C:\\Users\\ASUSTeK\\OneDrive\\DocumentenGitHub\\internship_sofie\\" #data from github dir
}
setwd(Dir)
data2 <- read.csv(paste0(Dir,"Data\\allPMSData.csv"), header=TRUE, sep=) #upload data
norms <-read.table(paste0(Dir,"Data\\FemaleSubjects_1-20.txt"), header=TRUE, fill=TRUE) #upload norms IAPs images

#we make a new variable that has value 1 for the first TestMoment and 2 for the second TestMoment
#These moments were counterbalanced. when the order was B-A and the moment is B, this means it is the first test moment, and vice versa for A-B and moment A. 
data$TestMoment[data$Order == "A-B" & data$Moment == "A"] = 1# TestMoment 1 == Follicular phase
data$TestMoment[data$Order == "B-A" & data$Moment == "A"] = 2# TestMoment 2 == Luteal phase
data$TestMoment[data$Order == "A-B" & data$Moment == "B"] = 2
data$TestMoment[data$Order == "B-A" & data$Moment == "B"] = 1
#sum(is.na(data$TestMoment))#check if there are still values missing (NA)

# new variable PMSSCORE NEW iedereen pms 0 ook 0 iedereen die 1 OF 2 heeft wordt 1, 
data$PMS[data$PMSScore==0] = 'noPMS'
data$PMS[data$PMSScore==1] = 'PMS'
data$PMS[data$PMSScore==2] = 'PMS' #PMDD, mr niet officiële diagnose dus gewoon PMS

data$rt= data$rt/1000 #put rt in sec instead of ms

#we make factors of the independable variables
data$Subject <- factor(data$ID)
levs<-union(data$ID, data$ID)
data$newid <- factor(data$ID, levels=levs, labels=seq_along(levs)) #this code replaces the '627, 534 IDs with 1, 2, 3, )
data$PMSScore <- factor(data$PMSScore)
data$PMS <- factor(data$PMS)
data$Moment <- factor(data$TestMoment) # This removes "A and B", A == 1, B == 2 now

# Exclude data?
data_allcontraception <-data
# exclude everyone on the pill/copper spiral/other: only those with Natural Contraception are left included
data<-subset(data, Contraception!="Pill" & Contraception!="other" & Contraception!="Cop. Coil" & Contraception!="Hor. Coil" & Contraception!='Hor.Coil')

dataBig = data # Saved data that contains stimuli columns
data = data[, -which(names(data) == "X" | names(data) == "Stimulus" | names(data) == "Valence" | names(data) == "Arousal" | names(data) == "rt")] #removes these columns
data= distinct(data)

data <- subset(data,BSRI!=0 ) #remove datapoints where BSRI = 0
dataBig_out<-dataBig #the dataBig with the rt outliers
dataBig2 <- subset(dataBig, rt < 16)#Dit zijn de data waar de rt outliers uitgehaald zijn! 

#dataframe with the norms for the stimuli (IAPs images)
norms$IAPS <-round(norms$IAPS)
un<-c('1440', '1463', '1610', '1710', '1722', '1750', '2057', '2070', '2160', '2165', '2340', '2360', '2800', '3261', '4180', '4290', '4490', '4531',  '4550', '4561', '4658', '5030', '5600', '5800', '5982', '6312', '6313', '7182', '7211', '7224', '7238', '7380', '7480', '7481', '9220', '9300', '9320', '9584', '9592', '9594', '9600', '9911', '9920', '9921') # all the unique(data$Stimulus) in a list
norms<-as.data.frame(norms) # make a dataframe
norms$row_num <- seq.int(nrow(norms)) # give row numbers
#move column with names 
norms <- norms %>%
  relocate(desc, .after=row_num)
norms<-subset(norms, IAPS%in% un ) #we now have table with the norms for ONLY the stimuli used in this PMS experiment
norms<-norms[-c(4),] #we remove the second 1610 because it is double for some reason
#now we add the sd and means from these data to this dataframe
# https://stackoverflow.com/questions/21982987/mean-per-group-in-a-data-frame
# norms$valmn_pms<- mean(dataBig2$Valence)
norms<-cbind(norms, round(ddply(dataBig2, .(Stimulus), summarize,  valmn_pms=mean(Valence))[2])/10)
norms<-cbind(norms, round(ddply(dataBig2, .(Stimulus), summarize,  aromn_pms=mean(Arousal))[2])/10)
norms<-cbind(norms, round(ddply(dataBig2, .(Stimulus), summarize,  valsd_pms=sd(Valence))[2])/10)
norms<-cbind(norms, round(ddply(dataBig2, .(Stimulus), summarize,  arosd_pms=mean(Arousal))[2])/10)
#make all columns unique!
colnames(norms)<-make.unique(names(norms))
# group stimuli depending on whether they are part of group A or group B in exp
A<-unique(dataBig2$Stimulus[dataBig2$Order=='A-B' & dataBig2$Moment==1])# two groups of stimuli: A and B
B <-unique(dataBig2$Stimulus[dataBig2$Order=='B-A' & dataBig2$Moment==1])
norms$group[norms$IAPS %in% A]='A'# add this to the 'norms' dataset
norms$group[norms$IAPS %in% B]='B'
```

```{r functions, echo=FALSE, results='asis'}
  # violin function
    geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                                 position = "dodge", trim = TRUE, scale = "area",
                                 show.legend = NA, inherit.aes = TRUE, ...) {
      layer(data = data,mapping = mapping,stat = stat,geom = GeomFlatViolin,
            position = position,show.legend = show.legend, inherit.aes = inherit.aes,
      params = list(trim = trim,scale = scale,...))}

GeomFlatViolin <- ggproto("GeomFlatViolin", Geom,
          setup_data = function(data, params) {
            data$width <- data$width %||%
              params$width %||% (resolution(data$x, FALSE) * 0.9)
            # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
            data %>%
              group_by(group) %>%
              mutate(ymin = min(y),
                     ymax = max(y),
                     xmin = x,
                     xmax = x + width / 2) },
          draw_group = function(data, panel_scales, coord) {
            # Find the points for the line to go all the way around
            data <- transform(data, xminv = x,xmaxv = x + violinwidth * (xmax - x))
            # Make sure it's sorted properly to draw the outline
            newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),
                             plyr::arrange(transform(data, x = xmaxv), -y))
            # Close the polygon: set first and last point the same
            # Needed for coord_polar and such
            newdata <- rbind(newdata, newdata[1,])
            ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))},
          draw_key = draw_key_polygon,
          default_aes = aes(weight = 1, colour = "grey20", fill = "white", size = 0.5,
                            alpha = NA, linetype = "solid"), required_aes = c("x", "y"))
    #standard error function
    standard_error <- function(x) sd(x)/sqrt(length(x))
    
#function for split violin
    GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin, 
                           draw_group = function(self, data, ..., draw_quantiles = NULL) {
  data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
  grp <- data[1, "group"]
  newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
  newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
  newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])
  if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
    stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <=
      1))
    quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
    aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
    aesthetics$alpha <- rep(1, nrow(quantiles))
    both <- cbind(quantiles, aesthetics)
    quantile_grob <- GeomPath$draw_panel(both, ...)
    ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))}
  else {ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...)) }})

geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ..., 
                              draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE, 
                              show.legend = NA, inherit.aes = TRUE) {
  layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, 
        position = position, show.legend = show.legend, inherit.aes = inherit.aes, 
        params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))}
```

## Intro

This study looked into stress, rumination and emotion expression during the premenstrual phase with both healthy participants as participants who have PMS (premenstrual syndrome).

### PMS

PMS is a clinical disorder that is characterized by behavioral and physical symptoms that occur during the luteal phase, which we will refer to as the premenstrual phase.

!["Image Source: https://helloclue.com/articles/cycle-a-z/the-menstrual-cycle-more-than-just-the-period"](figures/MC.png){width=80%}

##### Symptoms

- disappear 1-2 days into menstruation
- decreased serotonin levels
- etiology and symptoms of PMS and depression are linked

### PMDD

PMDD (Premenstrual Dysphoric Disorder) has recently been added to the DSM, this is a more severe version of PMS.

##### Prevalence

- 75% of women experience some symptoms
- 20-30%: moderate to severe symptoms
- 5-8% PMDD levels of symptoms

***

### Screening

![](figures/screening.png){width=80%}

* screening tool for premenstrual symptoms: 
    + no/mild
    + medium-severe
    
### PMS

* three groups: low and high PMS and PMDD.
* but, because PMDD no official diagnosis, taken together to form the 'noPMS' and 'PMS' group

### TestMoment

* determined per participant, based on cycle
* invitation via e-mail + 24 h reminder
* execution via LimeSurvey
* counterbalanced across participants

***

### Hypotheses

#### control vs premenstrual phase:

- higher stress?
- more rumination? 
- more negative responses? explicit: ratings, implicit: video emotion expressions

***

## PMS, PSS and BSRI

#### PMS vs no PMS: 
- PSS
- BSRI
+ Interactie testmoment

```{r echo=FALSE}
ui<- fluidPage( # makes the User Interface
    selectInput("formula_choice", label="Choose a Formula:",
            choices= c('PSS ~ PMS', 'BSRI ~ PMS', 'PSS~ PMS*TestMoment', 'BSRI ~PMS*TestMoment'),
            selected='PSS ~ TestMoment'), # puts the choices in the first element which is accessed via input$formula_choice
     tabsetPanel(type = "tab",
                  tabPanel("pirateplot", plotOutput("pirateplot")),
                 tabPanel("raincloud", plotOutput("raincloud")),
                 tabPanel("splitviolin", plotOutput("splitviolin")),
                 tabPanel("overlap", plotOutput("overlap")),
                 tabPanel("AIC table", tableOutput("table")),
                 tabPanel("Anova", verbatimTextOutput("Anova")),
                 tabPanel("emmeans",verbatimTextOutput("emmeans"))
         ))

server <- function (input, output){ 
  
  output$pirateplot<- renderPlot({ 
    par(mfcol = c(1, 1))
      pirateplot(
      formula= 'PSS~ PMS*TestMoment',
      data=data,
      theme= 3,
      pal= "xmen",
      main= 'PSS~ PMS*TestMoment',
      xlab="",
    )
  }, height= 600)
  
    p_pms <-reactive({
    p<-(p()[[3]][1]) # this gets the p-value of the first row, for PMS
    star=c()
    if (p> 0.05) {star=''
    }else if (p<0.0005){star='***'
    }else if (p<0.005){star='**'
    }else if (p<0.05) {star='*'}
    star})
  
  p<-reactive({
        tabel<-c()
    for (i in 1:length(models())){
        AIC<- AIC(models()[[i]])
        tabel <- c(tabel,round(AIC))}
    chosenModel<-models()[which(tabel == min(tabel))]
       Anova_1 <- Anova(chosenModel[[1]])
       cat(sprintf("\nAnova\n"))
       Anova_1 })

  #https://wellcomeopenresearch.org/articles/4-63   some info on rainclouds
  output$raincloud <- renderPlot({
    if ((grepl("PSS", input$formula_choice))){
      ggplot(data, aes(x = PMS, y = PSS, fill=PMS))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0), alpha=.5,adjust =2)+
        geom_boxplot(width= .15, outlier.shape = NA)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        ylab('PSS')+xlab('PMS')+coord_flip()+theme_cowplot()+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("distribution PSS in PMS vs no PMS")
    }else{
      ggplot(data, aes(x = PMS, y = BSRI, fill=PMS))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0),alpha=.5,adjust =2)+
        ylab('BSRI')+xlab('PMS')+coord_flip()+theme_cowplot()+
        geom_boxplot(width= .15, outlier.shape = NA)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("distribution BSRI in PMS vs no PMS")
      }
  }, height=600)
  
    output$splitviolin <-renderPlot({
      if ((grepl("PSS", input$formula_choice)==TRUE)&!(grepl("TestMoment", input$formula_choice))){
              max_y<-max(as.integer(data$PSS))
        dmean<-summarySE(data, measurevar="PSS", groupvars=c('PMS'))
         ggplot(data, aes(x=1, y=PSS, fill=PMS))+
            geom_split_violin(adjust =1.5, alpha=.5)+
            geom_boxplot(aes(x = 1, y = PSS, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = 1, y = PSS, group = PMS, fill = PMS), position= position_dodge(0.6), shape = 21, size=4)+
            annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label=sprintf("\n%s\n", p_pms()), size=10)+
           # annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='3', size=10)+
            geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            ggtitle('PSS ~ PMS')
      }else if (grepl('PSS', input$formula_choice)&(grepl("TestMoment", input$formula_choice))){
        max_y<- max(as.integer(data$PSS))
        dmean<-summarySE(data, measurevar="PSS", groupvars=c('PMS', 'Moment'))
          ggplot(data, aes(x=Moment, y=PSS, fill=PMS))+
            geom_split_violin(adjust =1.5, alpha=.5, colour= NA)+
            geom_boxplot(aes(x = Moment, y = PSS, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = as.numeric(Moment), y = PSS, group = PMS, fill = PMS), position= position_dodge(0.2), shape = 21, size=4)+
          scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
            annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='*', size=8)+
            annotate('text', x=2, y=max_y+(max_y/10)+(max_y/100), label='*', size=8)+
            geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            geom_segment(aes(x = 1.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 2.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            ggtitle('PSS ~ PMS * TestMoment')
    } else if (grepl('BSRI', input$formula_choice)&(grepl("TestMoment", input$formula_choice))){
    max_y<-max(as.integer(data$BSRI))
  dmean<-summarySE(data, measurevar="BSRI", groupvars=c('PMS', 'Moment'))
    ggplot(data, aes(x=Moment, y=BSRI, fill=PMS))+
      geom_split_violin(adjust =1.5, alpha=.5, colour= NA)+
      geom_boxplot(aes(x = Moment, y = BSRI, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
      geom_point(data = dmean, aes(x = as.numeric(Moment), y = BSRI, group = PMS, fill = PMS), position= position_dodge(0.2), shape = 21, size=4)+
    scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
      annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='*', size=8)+
      annotate('text', x=2, y=max_y+(max_y/10)+(max_y/100), label='**', size=8)+
      geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
      geom_segment(aes(x = 1.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 2.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
      ggtitle('PSS ~ PMS * TestMoment')
    } else {max_y<-max(as.integer(data$BSRI))
        dmean<-summarySE(data, measurevar="BSRI", groupvars=c('PMS'))
        ggplot(data, aes(x=1, y=BSRI, fill=PMS))+
            geom_split_violin(adjust =1.5, alpha=.5)+
            geom_boxplot(aes(x = 1, y = BSRI, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = 1, y = BSRI, group = PMS, fill = PMS), position= position_dodge(0.6), shape = 21, size=4)+
            annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label=sprintf("\n%s\n", p_pms()), size=10)+
           # annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='3', size=10)+
            geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            ggtitle('BSRI ~ PMS')
    }
  }, height=600)
    
    output$overlap <- renderPlot({
      if (grepl('PSS', input$formula_choice) &grepl('TestMoment', input$formula_choice)){
        max_y<-max(as.integer(data$PSS))
        dmean<-summarySE(data, measurevar="PSS", groupvars=c('PMS', 'Moment'))
        ggplot(dataBig2, aes(x=Moment, y=PSS, fill=PMS))+
            geom_flat_violin (aes(fill=PMS), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
            geom_boxplot(aes(x=Moment, y=PSS, fill=PMS), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
            geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=PSS, group=PMS, colour=PMS), size=1.5)+
            geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = PSS, group = PMS, fill= PMS), shape = 21, size=6)+
                annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='*', size=8)+
      annotate('text', x=2, y=max_y+(max_y/10)+(max_y/100), label='**', size=8)+
      geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
      geom_segment(aes(x = 1.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 2.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
            ggtitle('PSS ~ PMS * TestMoment')
    }else if (grepl('PSS', input$formula_choice) & !grepl('TestMoment', input$formula_choice)){
      max_y<-max(as.integer(data$PSS))
            dmean<-summarySE(data, measurevar="PSS", groupvars=c('PMS'))
          ggplot(dataBig2, aes(x = PMS, y = PSS)) +
            geom_flat_violin(aes(fill=PMS),position = position_nudge(x =.2, y = -1), adjust = 1.5, alpha = .5, colour = NA)+
            geom_point(aes(colour=PMS),position=position_jitter(width=.15), size=.25)+
            geom_boxplot(aes(x = PMS, y = PSS, fill = PMS),outlier.shape= NA, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = as.numeric(PMS)+.2, y = PSS, group=PMS, fill=PMS), shape = 21, size=6)+
             geom_line(data=dmean, aes(x=as.numeric(PMS)+.2, y=PSS), size=1, colour='black')+
            geom_segment(aes(x = 1.2, y=max_y+(max_y/10)+(max_y/100), xend = 2.2, yend=max_y+(max_y/10)+(max_y/100)), size= 1.7)+
          annotate('text', x=1.6, y=max_y+(max_y/10)+(max_y/100), label=sprintf("\n%s\n", p_pms()), size=10)+
            scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
            ggtitle('PSS~PMS')
    }
    else if (grepl('BSRI', input$formula_choice) & grepl('TestMoment', input$formula_choice)){
        max_y<-max(as.integer(data$BSRI))
        dmean<-summarySE(data, measurevar="BSRI", groupvars=c('PMS', 'Moment'))
        ggplot(dataBig2, aes(x=Moment, y=BSRI, fill=PMS))+
            geom_flat_violin (aes(fill=PMS), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
            geom_boxplot(aes(x=Moment, y=BSRI, fill=PMS), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
            geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=BSRI, group=PMS, colour=PMS), size=1.5)+
            geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = BSRI, group = PMS, fill= PMS), shape = 21, size=6)+
                annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='*', size=8)+
      annotate('text', x=2, y=max_y+(max_y/10)+(max_y/100), label='**', size=8)+
      geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
      geom_segment(aes(x = 1.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 2.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
            ggtitle('BSRI ~ PMS * TestMoment')
    }else {
            max_y<-max(as.integer(data$BSRI))
            dmean<-summarySE(data, measurevar="BSRI", groupvars=c('PMS'))
          ggplot(dataBig2, aes(x = PMS, y = BSRI)) +
            geom_flat_violin(aes(fill=PMS),position = position_nudge(x =.2, y = -1), adjust = 1.5, alpha = .5, colour = NA)+
            geom_point(aes(colour=PMS),position=position_jitter(width=.15), size=.25)+
            geom_boxplot(aes(x = PMS, y = BSRI, fill = PMS),outlier.shape= NA, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = as.numeric(PMS)+.2, y = BSRI, fill=PMS), shape = 21, size=6)+
             geom_line(data=dmean, aes(x=as.numeric(PMS)+.2, y=BSRI), size=1, colour='black')+
            geom_segment(aes(x = 1.2, y=max_y+(max_y/10)+(max_y/100), xend = 2.2, yend=max_y+(max_y/10)+(max_y/100)), size= 1.7)+
          annotate('text', x=1.6, y=max_y+(max_y/10)+(max_y/80), label=sprintf("\n%s\n", p_pms()), size=10)+
            scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
            ggtitle('BSRI~PMS')
        }
    }, height=600)
      
     models <- reactive({ # we need to create this within a reactive context to be able to access the formula_choice
        m <- c()
        # Formula <- 'PSS~ PMS*TestMoment + (1|Subject)'
        Formula <- paste0(input$formula_choice, '+ (1|Subject)')
        tryCatch({ d0.1 <- lmer(Formula,data=data); # if this formula works
          m <- c(m, d1=d0.1)}, #we add this
          error=function(e){})
        tryCatch({ d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d1=d0.2)}, error=function(e){})
        tryCatch({ d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d3=d0.3)}, error=function(e){})
        tryCatch({ d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d4=d0.4)}, error=function(e){})
        tryCatch({ d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d5=d0.5) }, error=function(e){})
        tryCatch({ d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d6=d0.6) }, error=function(e){})
        tryCatch({ d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
          models <- c(models, d7=d0.7) }, error=function(e){})
        tryCatch({ d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d8=d0.8) }, error=function(e){})
        tryCatch({ d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d9=d0.9) }, error=function(e){})
        m
     })
     
 output$table <-renderTable({
  modelNames<-c()
  tabel<-c()
  chosenModel<-c()
  for (i in 1:length(models())){
    modelNames<-c(modelNames, names(models()[i]))
    AIC<-AIC(models()[[i]])
    tabel <- c (tabel, AIC)}
    chosenModel = modelNames[which(tabel == min(tabel))]
    tabel <- data.frame(Models=c('chosen  Model:', modelNames), AIC= c(chosenModel, round(tabel)))
    tabel
})
  
  output$Anova <- renderPrint({
       cat(sprintf("\nAnova\n"))
       p()
    })
  
output$emmeans <- renderPrint({
  tabel<-c()
  for (i in 1:length(models())){
      AIC<- AIC(models()[[i]])
      tabel <- c(tabel,round(AIC))}
  chosenModel<-models()[which(tabel == min(tabel))]
    cat(sprintf("\n formula: %s\n", input$formula_choice))
    if ((grepl("TestMoment", input$formula_choice)==FALSE)){
      cat(sprintf("\n~ PMS\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ TestMoment, adjust ="fdr", type="response")
      print(Emm)}
    if (grepl("TestMoment", input$formula_choice)){
      cat(sprintf("\n~ PMS*TestMoment\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ PMS*TestMoment, adjust ="fdr", type="response")
      print(Emm)}
  })

}
shinyApp(ui=ui, server=server, options=list(height=800))
```
we do (G)LMM: generalized linear mixed models
PSS or BSRI as dependable variable
PMS(2 levels) x TestMoment (2 levels)

AIC: Akaike Information Criterion: says which model best (lowest AIC) 

### conclusions

* PSS is higher in premenstrual phase
    + sign effect of PMS on PSS
    + no sign difference between testmoment 1 and 2 with the PMS group!

* BSRI is higher in PMS than in noPMS group
   + no effect of testmoment on BSRI

### PSS: Perceived Stress Scale

#### Norm Groups PSS (young) women

```{r echo=FALSE}
meanPSS<-mean(data$PSS)
maxPSS<-max(data$PSS)
minPSS<-min(data$PSS)
```

Women have on average higher stress scales. 

Perceived Stress Scale Sheldon Cohen
women: mean=13.7, SD:6.6
men: mean:12.1, SD: 5.9
age 18-29: 14.2, SD: 6.2
30-44: 13, 6.2
45-54: 12.6, 6.1

KIJK of we zelfde PSS items gebruiken

https://bmcpsychiatry.biomedcentral.com/articles/10.1186/s12888-016-0875-9/tables/6
women age 20-29: Mn=8.2, SD= 4.6
women age 40-40: Mn=7.6, SD= 4.2

https://www.frontiersin.org/files/Articles/558691/fpsyt-11-558691-HTML/image_m/fpsyt-11-558691-t003.jpg

mean score of the population; 18.10 (moderate stress level)

https://www.dovepress.com/cr_data/article_fulltext/s317000/317059/img/PRBM_A_317059_t0002.jpg

PSS during pandemic:D
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7680058/


![PSS](figures/PSS.png){width=80%}
![Covid Stress 2020](figures/covid_stress.png){width=100%}

### BSRI:
Brief State RUmination Index

![Marchetti et al. The Brief State Rumination Inventory (BSRI): Validation and Psychometric Evaluation](figures/BSRI.png){width=70%}
!["Altan-Atalay et al., 2020"](figures/BSRI_norms2.png){width=100%}


## DASS

### DASS-21_R

#### Depression Anxiety Stress Scale

* DASS: 3 subschalen
 + DASS_Total, DASS_Stress, DASS_Anxiety, DASS_Depression
* effect of PMS vs no PMS
   + no interaction Testmoment: Trait, not State
   + interaction PSS? 

#### onderzoeksvraag: PMS vs noPMS voor:
- DASS_alle subschalen
- interactie PSS


```{r echo=FALSE}
ui<- fluidPage( # makes the User Interface
    selectInput("formula_choice", label="Choose a Formula:",
            choices= c('DASS_Stress ~ PMS', 'DASS_Anxiety ~ PMS', 'DASS_Depression ~ PMS'),
            selected='DASS_Stress ~ PMS'), # puts the choices in the first element which is accessed via input$formula_choice
     tabsetPanel(type = "tab",
                  tabPanel("pirateplot", plotOutput("pirateplot")),
                  tabPanel("raincloud", plotOutput("raincloud")),
                 tabPanel("splitviolin", plotOutput("splitviolin")),
                 tabPanel("AIC table", tableOutput("table")),
                 tabPanel("Anova", verbatimTextOutput("Anova")),
                 tabPanel("emmeans",verbatimTextOutput("emmeans"))
         ))

server <- function (input, output){ #we have to add this to the server

  output$pirateplot<- renderPlot({
    par(mfcol = c(1, 1))
      pirateplot(formula= input$formula_choice,data=data,
      theme= 1,pal= "xmen",main= input$formula_choice,
    )
  }, height=600)

  #https://wellcomeopenresearch.org/articles/4-63   some info on rainclouds
  #PMS vs noPMS over 2 fases Testmoment, https://github.com/jorvlan/raincloudplots
    output$raincloud <- renderPlot({
      if ((grepl("Stress", input$formula_choice))){
        ggplot(data, aes(x = PMS, y = DASS_Stress, fill=PMS))+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          geom_boxplot(width= .15, outlier.shape = NA)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Stress in PMS vs no PMS")
      }else if ((grepl("Anxiety", input$formula_choice))){
        ggplot(data, aes(x = PMS, y = DASS_Anxiety, fill=PMS))+
          geom_boxplot(width= .15, outlier.shape = NA)+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Anxiety in PMS vs no PMS")
      }else {
        ggplot(data, aes(x = PMS, y = DASS_Anxiety, fill=PMS))+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Depression in PMS vs no PMS")
      }
    }, height=600)
    
  p_pms <-reactive({
    p<-(p()[[3]][1]) # this gets the p-value of the first row, for PMS
    star=c()
    if (p> 0.05) {star=''
    }else if (p<0.0005){star='***'
    }else if (p<0.005){star='**'
    }else if (p<0.05) {star='*'}
    star
  })
  
  p<-reactive({
        tabel<-c()
    for (i in 1:length(models())){
        AIC<- AIC(models()[[i]])
        tabel <- c(tabel,round(AIC))}
    chosenModel<-models()[which(tabel == min(tabel))]
       Anova_1 <- Anova(chosenModel[[1]])
       cat(sprintf("\nAnova\n"))
       Anova_1
  })
  
    output$splitviolin <- renderPlot({
      if ((grepl("Stress", input$formula_choice))){
        max_y<-max(as.integer(data$DASS_Stress))
        dmean<-summarySE(data, measurevar="DASS_Stress", groupvars=c('PMS'))
         ggplot(data, aes(x=1, y=DASS_Stress, fill=PMS))+
            geom_split_violin(adjust =1.5, alpha=.5)+
            geom_boxplot(aes(x = 1, y = DASS_Stress, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = 1, y = DASS_Stress, group = PMS, fill = PMS), position= position_dodge(0.6), shape = 21, size=4)+
            annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label=sprintf("\n%s\n", p_pms()), size=10)+
           # annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='3', size=10)+
            geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            ggtitle('DASS_Stress ~ PMS')
      }  else if ((grepl("Anxiety", input$formula_choice))) {
        max_y<-max(as.integer(data$DASS_Anxiety))
        dmean<-summarySE(data, measurevar="DASS_Anxiety", groupvars=c('PMS'))
         ggplot(data, aes(x=1, y=DASS_Anxiety, fill=PMS))+
            geom_split_violin(adjust =1.5, alpha=.5)+
            geom_boxplot(aes(x = 1, y = DASS_Anxiety, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = 1, y = DASS_Anxiety, group = PMS, fill = PMS), position= position_dodge(0.2), shape = 21, size=4)+
            annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label=sprintf("\n%s\n", p_pms()), size=10)+
            geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
           ggtitle('DASS_Anxiety ~ PMS')
      } else {
                  max_y<-max(as.integer(data$DASS_Depression))
        dmean<-summarySE(data, measurevar="DASS_Depression", groupvars=c('PMS'))
         ggplot(data, aes(x=1, y=DASS_Depression, fill=PMS))+
            geom_split_violin(adjust =1.5, alpha=.5)+
            geom_boxplot(aes(x = 1, y = DASS_Depression, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = 1, y = DASS_Depression, group = PMS, fill = PMS), position= position_dodge(0.2), shape = 21, size=4)+
            annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label=sprintf("\n%s\n", p_pms()), size=10)+
            geom_segment(aes(x = 0.955, y = (max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+(max_y/10)-(max_y/80))), size= 2)+
            ggtitle('DASS_Depression ~ PMS')
      }
    }, height=600)
    
    
     models <- reactive({ # we need to create this within a reactive context to be able to access the formula_choice
        m <- c()
        # Formula <- 'DASS_Stress ~ PMS + (1|Subject)'
        Formula <- paste0(input$formula_choice, '+ (1|Subject)')
        tryCatch({ d0.1 <- lmer(Formula,data=data); 
          m <- c(m, d1=d0.1)}, error=function(e){})
        tryCatch( { d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d1=d0.2)},  error=function(e){})
        tryCatch({ d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d3=d0.3)},  error=function(e){})
        tryCatch({ d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d4=d0.4)}, error=function(e){})
        tryCatch( { d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d5=d0.5) },  error=function(e){})
        tryCatch(  { d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d6=d0.6) },  error=function(e){})
        tryCatch( { d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
          models <- c(models, d7=d0.7) },   error=function(e){})
        tryCatch( { d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d8=d0.8) },   error=function(e){})
        tryCatch( { d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d9=d0.9) },  error=function(e){})
        m
     })
  output$table <-renderTable({
    modelNames<-c()
    tabel<-c()
    for (i in 1:length(models())){
      modelNames<-c(modelNames, names(models()[i]))
      AIC<-AIC(models()[[i]])
      tabel <- c (tabel, round(AIC))}
      chosenModel = modelNames[which(tabel == min(tabel))]
      data.frame(Models=c('chosen  Model:', modelNames), AIC= c(chosenModel, tabel))
  })

  output$Anova <- renderPrint({
       cat(sprintf("\nAnova\n"))
       p()
    })
  
  output$emmeans <- renderPrint({
  tabel<-c()
  for (i in 1:length(models())){
      AIC<- AIC(models()[[i]])
      tabel <- c(tabel,round(AIC))}
  chosenModel<-models()[which(tabel == min(tabel))]
    cat(sprintf("\n emmeans of formula: %s\n", input$formula_choice))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ PMS, adjust ="fdr", type="response")
      print(Emm)
  })

}

shinyApp(ui=ui, server=server, options=list(height=800))
```

### Conclusions
* sign more stress PMS than no PMS
* sign more anxiety PMS than no 
* sign more depression PMS than no PMS

### Interpretation of DASS

!["de Beurs et al., 'De DASS', 2001"](figures/DASS.png){width=80%}


## reaction times

we plot the reaction times to find the outliers and filter the data

```{r, echo=FALSE}
#plot reaction times with raincloudplot
d<-melt(data.frame(rt=c(dataBig_out$rt))) # we melt to wide format 
ggplot(d, aes(x = variable, y = value, fill=variable))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
  ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
  geom_point(position=position_jitter(width=.15), size=2)+
  geom_boxplot(width= .10, outlier.shape = NA)+
  theme(legend.position="none")+
  ggtitle("reaction times with outliers")

summary(dataBig_out$rt)

print('upper 99.85% bound')
quantile (dataBig_out$rt, 0.9985)

dataBig_out <- subset(dataBig_out, rt < 30)
d<-melt(data.frame(rt=c(dataBig_out$rt)))
ggplot(d, aes(x = variable, y = value, fill=variable))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
  geom_point(position=position_jitter(width=.15), size=0.25)+
  ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
  geom_boxplot(width= .10, outlier.shape = NA)+
  theme(legend.position="none")+
  guides(fill=FALSE)+
  ggtitle("reaction times < 16 sec")

summary(dataBig_out$rt)

out<-boxplot.stats(dataBig_out$rt)$out#outliers
out_ind<-which(dataBig_out$rt %in% c(out))#row numbers that contain outliers
boxplot(dataBig_out$rt, ylab='rt') #boxplot
mtext(paste('boxplot with outliers')) #boxplot with outliers
```



## IAPs Images

#### IAPs images

- Rating of 22 IAPS images while webcam records
  +  counterbalanced across TestMoment: e.g. during moment 1 a puppy, during moment 2 a different puppy. this order (serie A of images and serie B of images)

- Report experienced Valence, Arousal

![](figures/screening.png){width=80%}

These were images that were either negative, positive or neutral. 
22 matched images (e.g. in TestMoment 1 image of needle in arm, in TestMoment 2 needle in leg. or image puppy and image of another puppy)

participants could indicate how the images scored for them on valence and arousal

these already have the rt data filtered under 16 sec (outliers removed)

we look at how people answer on the stimuli: can we categorize the stimuli in valence and arousal? Are there weird answers? 

```{r echo=FALSE}
# unique<-sort(unique(dataBig$Stimulus), decreasing=FALSE) #find all the stimuli
# we maken een density plotvoor zowel valence als arousal voor elke stimulus (2x22)
ui<- fluidPage( 
    radioButtons("stimulus", label="Choose a Stimulus:",
            choices= c('1440', '1463', '1610', '1710', '1722', '1750', '2057', '2070', '2160', '2165', '2340', '2360', '2800', '3261', '4180', '4290', '4490', '4531',  '4550', '4561', '4658', '5030', '5600', '5800', '5982', '6312', '6313', '7182', '7211', '7224', '7238', '7380', '7480', '7481', '9220', '9300', '9320', '9584', '9592', '9594', '9600', '9911', '9920', '9921'), inline=TRUE,
            selected='1440'),
    tabsetPanel(type = "tab",
      tabPanel("densityplot", plotOutput("densityplot")),
      tabPanel("IAPs_Image", plotOutput("IAPs_Image"))
    )
)

server <- function (input, output){ 
  #we make a density plot of valence/arousal per stimulus.
  output$densityplot<- renderPlot({
    d<-melt(data.frame(valence=c(dataBig2$Valence[dataBig2$Stimulus==input$stimulus]),arousal=c(dataBig2$Arousal[dataBig2$Stimulus==input$stimulus])))
    d2<-data.frame(valence=c(dataBig2$Valence[dataBig2$Stimulus==input$stimulus]), ID=c(dataBig2$newid[dataBig2$Stimulus==input$stimulus])) 
    min<-d2$ID[which(d2$valence==min(d2$valence))]#ids of min valence
    max<-d2$ID[which(d2$valence==max(d2$valence))]#ids of max valence
    if (length(min)<length(max)){text=min } else {text=max}
    
    pirateplot(
      formula=value~variable,
      data=d,
      main= input$stimulus, pal='xmen',
      xlab= str_glue('outlier: {text}'))
  }, height=600)
  
  output$IAPs_Image <- renderImage({
    list(src=str_glue("Z:/shares/ghep_lab/ImageDatabases/IAPS/{input$stimulus}.jpg"),
         filetype="image/jpeg",
         width=400,
         height=300)
  })
}
shinyApp(ui=ui, server=server, options= list(height=800))
```



#### outliers newid's:

* 25: VI: times a negative reaction to nakedness/sex: 4180, 4290, 4490, 4550, 4561,4658
* 75: IV: neg reactie nakedness and sex (4531, 4490, 4180, 4658)
* 145: II, neg reaction nakedness (4290, 4561)
* 284: III: neg reactie baby (2057, 2070, 2165)

* 47: II: neg reaction to clouds (5982) and positive to a needle in an arm (9594)
* 89: II: pos reactie op trippy schilderijen (7182, 7238)
* 169: II: pos reactie op vrouw gered dr brandweer (9921)
* 194: II: neg reactie ijsbergen (5600) en pasta (194)
* 1: II: antwoord altijd 0 of 100, ook op saaie kast (7224), schilderij (7238)

one-time outliers:    
10  27  30  31  40  74  97 100 119 121 128 134 136 167 168 206 221
233 240 244 251 252 257 259 262 293 315 334 351 365 374 376


| 'medium'= 40-60 |  |
|:----|:----------------------|
|  **high valence, high arousal:** | 4658, 4561, 4658  |
| **high valence, low arousal:** |  2360, 5030, 5600, 5800, 5982, 5030, 5800, 5982 |
| **high valence, medium arousal:** | 1440, 1463, 1610, 1710, 1722, 1750, 2057, 2070, 2160, 2165, 2340 7480, 7481, 5600, 7480, 7481 |
| **low valence, high arousal:** | 2800, 3261, 6312, 6313, 7182, 7380, 6312, 6313, 7380, 9600, 9911, 9920, 9921 |
| **low valence, low arousal:** |  9220 |
| **low valence, medium arousal:** | 9300, 9320, 9584, 9592, 9594 |
| **medium valence, high arousal:** | 7182 |
| **medium valence, low arousal:** |  7224, 7224 |
| **medium valence, medium arousal:** |  7211, 7238, 4550, 7211, 7238 |


### mean reactions over all stimuli
plot mean reaction per participant over all stimuli: 
-mean valence
-mean arousal
-standard deviation



### Statistics

- plot means valence & arousal between groups (PMS, noPMS) on stimuli

- plot means testmoment x PMS

- statistical analysis: sign differences? 

```{r echo=FALSE}
ui<- fluidPage( 
      selectInput("formula_choice", label="Choose a Formula:",
            choices= c('Valence~PMS', 'Arousal~PMS', 'Valence~PMS * TestMoment', 'Arousal ~ PMS * TestMoment'),
            selected='Valence~PMS'),
    tabsetPanel(type = "tab",        
      tabPanel("pirateplot", plotOutput("pirateplot")),
      tabPanel('overlap', plotOutput('plotmeans')),
      tabPanel('splitviolin', plotOutput('splitviolin')),
      tabPanel('int_means', plotOutput('int_means')),
      tabPanel("AIC table", tableOutput("table")),
      tabPanel("Anova", verbatimTextOutput("Anova")),
      tabPanel("emmeans",verbatimTextOutput("emmeans"))
    )
)


server <- function (input, output){ 
  p_pms <-reactive({
    p<-(p()[[3]][1]) # this gets the p-value of the first row, for PMS
    if (p> 0.05) {''
    }else if (p<0.0005){'***'
    }else if (p<0.005){'**'
    }else if (p<0.05) {'*'}
  })
  
  #for emmeans: em[[2]][1] is the p-value for first row
  
  #we make a density plot of valence/arousal per stimulus.
  output$pirateplot<- renderPlot({
    pirateplot(
          formula= input$formula_choice,
          data=dataBig2,
          theme= 1,
          pal= "xmen",
          main= input$formula_choice,
        )
  }, height=600)
  
  output$plotmeans <-renderPlot({
    if (grepl('Arousal', input$formula_choice) &grepl('TestMoment', input$formula_choice)){
      dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMS', 'Moment'))
        p3 <- ggplot(dataBig2, aes(x=Moment, y=Arousal, fill=PMS))+
          geom_flat_violin (aes(fill=PMS), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
          geom_boxplot(aes(x=Moment, y=Arousal, fill=PMS), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
          geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=Arousal, group=PMS, colour=PMS), size=1.5)+
          geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = Arousal, group = PMS, fill= PMS), shape = 21, size=6)+
          scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
          annotate('text', x=1, y=105, label='*', size=8)+
          annotate('text', x=2, y=105, label='*', size=8)+
          geom_segment(aes(x = 0.97, y = 103, xend = 1.03, yend = 103), size= 2)+
          geom_segment(aes(x = 1.97, y = 103, xend = 2.03, yend = 103), size= 2)+
          ggtitle('Arousal ~ PMS * TestMoment')
        p3
    
        }else if (grepl('Valence', input$formula_choice) & grepl('TestMoment', input$formula_choice)){
      dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMS', 'Moment'))
        p3 <- ggplot(dataBig2, aes(x=Moment, y=Valence, fill=PMS))+
          geom_flat_violin (aes(fill=PMS), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
          geom_boxplot(aes(x=Moment, y=Valence, fill=PMS), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
          geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=Valence, group=PMS, colour=PMS), size=1.5)+
          geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = Valence, group = PMS, fill=PMS), shape = 21, size=6)+
          scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
          ggtitle('Valence~PMS * TestMoment')
        p3
    }
    else if (grepl('Arousal', input$formula_choice) & !grepl('TestMoment', input$formula_choice)){
      dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMS'))
          p1 <- ggplot(dataBig2, aes(x = PMS, y = Arousal)) +
            geom_flat_violin(aes(fill=PMS),position = position_nudge(x =.2, y = -1), adjust = 1.5, alpha = .5, colour = NA)+
            geom_point(aes(colour=PMS),position=position_jitter(width=.15), size=.25)+
            geom_boxplot(aes(x = PMS, y = Arousal, fill = PMS),outlier.shape= NA, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = as.numeric(PMS)+.2, y = Arousal, fill=PMS), shape = 21, size=6)+
             geom_line(data=dmean, aes(x=as.numeric(PMS)+.2, y=Arousal), size=1, colour='black')+
            geom_segment(aes(x = 1.2, y = 103, xend = 2.2, yend = 103), size= 1.7)+
          # annotate('text', x=1.6, y=105, label=sprintf("\n%s\n", p_pms()), size=10)+
            annotate('text', x=1.6, y=105, label='*', size=10)+
            scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
            ggtitle('Arousal~PMS')
        p1
    }else {
      dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMS'))
          p1 <- ggplot(dataBig2, aes(x = PMS, y = Valence)) +
            geom_flat_violin(aes(fill=PMS),position = position_nudge(x =.2, y = -1), adjust= 1.5, alpha = .5, colour = NA)+
            geom_point(aes(colour=PMS),position=position_jitter(width=.15), size=.25)+
            geom_boxplot(aes(x = PMS, y = Valence, fill = PMS),outlier.shape= NA, width = .1, colour = "black")+
            geom_point(data = dmean, aes(x = as.numeric(PMS)+.2, y = Valence, fill=PMS), shape = 21, size=6)+
            geom_line(data=dmean, aes(x=as.numeric(PMS)+.2, y=Valence), size=1, colour='black')+
          # annotate('text', x=1.6, y=70, label=sprintf("\n%s\n", p_pms()), size=8)+
            ggtitle('Valence~PMS')
            # coord_flip()
        p1
    }
  }, height=600)
          
  output$splitviolin <-renderPlot({
    if (grepl('Arousal', input$formula_choice)){
      max_y <- max( as.integer(dataBig2$Arousal) )
      dmean<-summarySE(dataBig2, measurevar=Arousal, groupvars=c('PMS', 'Moment'))
        p<- ggplot(dataBig2, aes(x=Moment, y=Arousal, fill=PMS))+
            geom_split_violin(adjust =1.5, alpha=.5, colour= NA)+
          geom_boxplot(aes(x = Moment, y = Arousal, fill = PMS), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
          geom_point(data = dmean, aes(x = as.numeric(Moment), y = Arousal, group = PMS, fill = PMS), position= position_dodge(0.2), shape = 21, size=4)+
        scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
          annotate('text', x=1, y=max_y+(max_y/10)+(max_y/100), label='*', size=8)+
          annotate('text', x=2, y=max_y+(max_y/10)+(max_y/100), label='*', size=8)+
          geom_segment(aes(x = 0.955, y=(max_y+(max_y/10)-(max_y/80)), xend = 1.055, yend = (max_y+max_y/10)-(max_y/80)), size= 2)+
          geom_segment(aes(x = 1.955, y=max_y+(max_y/10)-(max_y/80), xend = 2.055, yend = max_y+(max_y/10)-(max_y/80)), size= 2)+
          ggtitle('Arousal ~ PMS * TestMoment')
        p
    } else if (grepl('Valence', input$formula_choice)){
      dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMS', 'Moment'))
        p<- ggplot(dataBig2, aes(x=Moment, y=Valence, fill=PMS))+
            geom_split_violin(adjust=1.5,alpha=.5, colour=NA)+
          geom_boxplot(aes(x = Moment, y = Valence, fill = PMS), position= position_dodge(0.2) ,outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
          geom_point(data = dmean, aes(x = as.numeric(Moment), y = Valence, group = PMS, fill = PMS), position=position_dodge(0.2), shape = 21, size=4)+
          scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
          ggtitle('Valence ~ PMS * TestMoment')
        p
    }
  }, height=600)

  
  output$int_means <- renderPlot({
    if ((grepl('Valence', input$formula_choice))){
      dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('TestMoment', 'PMS'))# this function gives sd, se mean and default 95% C.I.
      p<-ggplot(dmean, aes(x=TestMoment, y=Valence, colour=PMS, group=PMS)) +
          geom_errorbar(aes(ymin=Valence-standard_error(Valence), ymax=Valence+standard_error(Valence), width=.1))+
        geom_line() +
        geom_point(size=3)
      p} else {
      dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('TestMoment', 'PMS'))# this function gives sd, se mean and default 95% C.I.
      p<-ggplot(dmean, aes(x=TestMoment, y=Arousal, colour=PMS, group=PMS)) +
          geom_errorbar(aes(ymin=Arousal-standard_error(Arousal), ymax=Arousal+standard_error(Arousal), width=.1))+
        geom_line() +
        geom_point(size=3)
      p}
  })
  
     models <- reactive({ # we need to create this within a reactive context to be able to access the formula_choice
        m <- c()
        # Formula <- 'DASS_Stress ~ PMS * TestMoment + (1|Subject)'
        Formula <- paste0(input$formula_choice, '+ (1|Subject)')
        tryCatch(
          { d0.1 <- lmer(Formula,data=dataBig2); # if this formula works
          m <- c(m, d1=d0.1)}, #we add this
          error=function(e){})
        tryCatch(
          { d0.2 <- glmer(Formula,data=dataBig2, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d1=d0.2)}, 
          error=function(e){})
        tryCatch(
          { d0.3 <- glmer(Formula,data=dataBig2, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d3=d0.3)}, 
          error=function(e){})
        tryCatch(
          { d0.4 <- glmer(Formula,data=dataBig2, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d4=d0.4)}, 
          error=function(e){})
        tryCatch(
          { d0.5 <- glmer(Formula,data=dataBig2, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d5=d0.5) }, 
          error=function(e){})
        tryCatch(
          { d0.6 <- glmer(Formula,data=dataBig2, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d6=d0.6) }, 
          error=function(e){})
        tryCatch(
          { d0.7 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
          models <- c(models, d7=d0.7) }, 
          error=function(e){})
        tryCatch(
          { d0.8 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d8=d0.8) }, 
          error=function(e){})
        tryCatch(
          { d0.9 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
          m <- c(m, d9=d0.9) }, 
          error=function(e){})
        m
     })
  
  output$table <-renderTable({
    modelNames<-c()
    tabel<-c()
    for (i in 1:length(models())){
      modelNames<-c(modelNames, names(models()[i]))
      AIC<-AIC(models()[[i]])
      tabel <- c (tabel, round(AIC))}
      chosenModel = modelNames[which(tabel == min(tabel))]
      tabel <- data.frame(Models=c('chosen  Model:', modelNames), AIC= c(chosenModel, tabel))
      tabel
  })
  
  p<-reactive({
        tabel<-c()
    for (i in 1:length(models())){
        AIC<- AIC(models()[[i]])
        tabel <- c(tabel,round(AIC))}
    chosenModel<-models()[which(tabel == min(tabel))]
       Anova_1 <- Anova(chosenModel[[1]])
       cat(sprintf("\nAnova\n"))
       Anova_1

    #            tabel<-c()
    # for (i in 1:length(m)){
    #     AIC<- AIC(m[[i]])
    #     tabel <- c(tabel,round(AIC))}
    # chosenModel<-m[which(tabel == min(tabel))]
    #    Anova_1 <- Anova(chosenModel[[1]])
    #    cat(sprintf("\nAnova\n"))
    #    an<-Anova_1
       
  })

  output$Anova <- renderPrint({
    p()
    })
  
  em <- reactive({
    tabel<-c()
    for (i in 1:length(models())){
      AIC<- AIC(models()[[i]])
      tabel <- c(tabel,round(AIC))}
    chosenModel<-models()[which(tabel == min(tabel))]
    cat(sprintf("\nemmeans of formula: %s\n", input$formula_choice))
    if ((grepl("TestMoment", input$formula_choice)==FALSE)){
      emmeans(chosenModel[[1]], pairwise ~ PMS, adjust ="fdr", type="response")
    }else{
        emmeans(chosenModel[[1]], pairwise ~ PMS*TestMoment, adjust ="fdr", type="response")
    }
    # tabel <- c()
    #     for (i in 1:length(m)){
    #   AIC<- AIC(m[[i]])
    #   tabel <- c(tabel,round(AIC))}
    # chosenModel<-m[which(tabel == min(tabel))]
    # cat(sprintf("\nemmeans of formula: %s\n", Formula))
    # if ((grepl("TestMoment", Formula)==FALSE)){
    #  em<- emmeans(chosenModel[[1]], pairwise ~ PMS, adjust ="fdr", type="response")
    # }else{
    #   em<-  emmeans(chosenModel[[1]], pairwise ~ PMS*TestMoment, adjust ="fdr", type="response")
    # }
    # 
  })
  
    output$emmeans <- renderPrint({
      em()
  })

}
shinyApp(ui=ui, server=server, options= list(height=800))
```

Boxplots contain the medians, circles represent the means

#### Conclusions

- sign diff for both Arousal in PMS vs no PMS

- no conclusions can be made for TestMoment: found no sign diff




### further data processing

- divide stimuli groups on valence (read about IAP images): plot stimuli on axis of valence and arousal


IAPS norms for Female Subjects
-norms: dataframe met daarin SD en mean voor Valence, Arousal voor normgroepen én die van deze studie
- pirateplots to compare norms and PMS means and valence



```{r echo=FALSE}
ui<- fluidPage( 

    radioButtons("choice", label="choose",
            choices= c('Valence mean', 'Valence SD', 'Arousal mean', 'Arousal SD'), inline=TRUE,
            selected='Valence mean'), 
    tabsetPanel(type = "tab",        
      tabPanel("plot", plotOutput("plot")),
      tabPanel('correlations', plotOutput('correlations')),
      tabPanel('groups', plotOutput('groups'))
    )
)


server <- function (input, output){ 
  
  output$plot <-renderPlot({
        p1 <- ggplot(norms, aes(x = valmn_pms, y = aromn_pms))+
          geom_point(position=position_jitter(width=.15), size=2, colour='red')+
          # geom_text(aes(label=IAPS),hjust=0, vjust=0, size=3)+
          geom_point(data= norms, aes(x=valmn, y=aromn), size=2, colour='black')+
          ggtitle("mean Arousal and Valence norm females")
        p1      
    })
    
    
    
# calculate correlations
    output$correlations<- renderPlot({
      # p1<- ggplot(norms$valmn, norms$valmn_pms, method=c('pearson'))
      if ((grepl("Valence", input$choice)==TRUE)&(grepl("mean", input$choice)==TRUE)){
        p<- ggscatter(norms, x='valmn', y='valmn_pms', 
                        add='reg.line', fullrange=TRUE,
                    conf.int=TRUE,
                    cor.coef=TRUE, cor.method='pearson', 
                    xlab='norm means Valence', ylab='PMS means Valence', 
                    xlim=c(0,10))+
          geom_segment(aes(x = 0, y = 0, xend = 10, yend = 10), size= 1, colour='red')
        p
        }

        else if ((grepl("Valence", input$choice)==TRUE)&(grepl("SD", input$choice)==TRUE)){
        p<- ggscatter(norms, x='valsd', y='valsd_pms', 
                        add='reg.line', fullrange=TRUE,
                    conf.int=TRUE,
                    cor.coef=TRUE, cor.method='pearson', 
                    xlab='norm SD Valence', ylab='PMS SD Valence')+
          geom_segment(aes(x = 0, y = 0, xend = 3, yend = 3), size= 1, colour='red')
        p
        }
        else if ((grepl("Arousal", input$choice)==TRUE)&(grepl("mean", input$choice)==TRUE)){
        p<- ggscatter(norms, x='aromn', y='aromn_pms', 
                        add='reg.line', fullrange=TRUE,
                    conf.int=TRUE,
                    cor.coef=TRUE, cor.method='pearson', 
                    xlab='norm means Arousal', ylab='PMS means Arousal', 
                    xlim=c(0,10))+
          geom_segment(aes(x = 0, y = 0, xend = 10, yend = 10), size= 1, colour='red')
        p}
        else {        p<- ggscatter(norms, x='arosd', y='arosd_pms', 
                        add='reg.line', fullrange=TRUE,
                    conf.int=TRUE,
                    cor.coef=TRUE, cor.method='pearson', 
                    xlab='norm SD Arousal', ylab='PMS SD Arousal')+
          geom_segment(aes(x = 0, y = 0, xend = 4, yend = 10), size= 1, colour='red')
        p}
  
  }, height=600)
  
    
    output$groups <- renderPlot({
      if ((grepl("Valence", input$choice)==TRUE)&(grepl("mean", input$choice)==TRUE)){
                p<- ggscatter(norms, x='valmn', y='valmn_pms', 
                      color= 'group',
                      palette=get_palette('npg', 2),
                      ellipse=TRUE, ellipse.type='convex',
                    xlab='norm means Valence', ylab='PMS means Valence', 
                    xlim=c(0,10))
        p      
    # http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/78-perfect-scatter-plots-with-correlation-and-marginal-histograms/
      # ggpar(p, xlim=c(0,10))
      }
      else if ((grepl("Valence", input$choice)==TRUE)&(grepl("SD", input$choice)==TRUE)){
                       p<- ggscatter(norms, x='valsd', y='valsd_pms', 
                      color= 'group',
                      palette=get_palette('npg', 2),
                      ellipse=TRUE, ellipse.type='convex',
                    xlab='norm SD Valence', ylab='PMS SD Valence')
        p } 
              else if ((grepl("Arousal", input$choice)==TRUE)&(grepl("mean", input$choice)==TRUE)){
                       p<- ggscatter(norms, x='aromn', y='aromn_pms', 
                      color= 'group',
                      palette=get_palette('npg', 2),
                      ellipse=TRUE, ellipse.type='convex',
                    xlab='norm means Arousal', ylab='PMS means Arousal', 
                    xlim=c(0,10))
        p } 
      else {
                       p<- ggscatter(norms, x='arosd', y='arosd_pms', 
                      color= 'group',
                      palette=get_palette('npg', 2),
                      ellipse=TRUE, ellipse.type='convex',
                    xlab='norm SD Arousal', ylab='PMS SD Arousal')
        p } 
                
    }, height=600)
}
shinyApp(ui=ui, server=server,options= list(height=800))

```
    
### Conclusions

The data are similar to those of the norms, except for Arousal. 

elk puntje is waar de mean van PMS en de mean van de normgroep samenkomen. Die zijn positief gecorreleerd, wat wilt zeggen dat de Valence ongeveer hetzelfde beoordeeld wordt in de PMS studie (als laag beoordeeld, ook laag in de normgroep). We zien geen grote verschillen tussen de foto's A en B. 




## Descriptives


```{r echo=FALSE}

#dataframe with the means of descriptives
knitr::kable(data.frame(
  PMS=c('cyclus duration:', round(mean(data$MenstrualDuration[data$PMS=='PMS']), digits=1),
        'Age:', round(mean(data$Age[data$PMS=='PMS']), digits=1),
        'first menstrual:', round(mean(data$FirstMenstrual[data$PMS=='PMS']), digits=1)
        ), 
  noPMS= c('cyclus duration:', round(mean(data$MenstrualDuration[data$PMS=='noPMS']), digits=1),
           'Age:', round(mean(data$Age[data$PMS=='noPMS']), digits=1),
           'first menstrual:', round(mean(data$FirstMenstrual[data$PMS=='noPMS']), digits=1)
           )
  ))

kable(table(data$Order))

nat<- length(unique(data_allcontraception$ID[data_allcontraception$Contraception=='Natural']))
hor <- length(unique(data_allcontraception$ID[data_allcontraception$Contraception=='Hor.Coil'|data_allcontraception$Contraception=='Hor. Coil']))
cop <- length(unique(data_allcontraception$ID[data_allcontraception$Contraception=='Cop.Coil']))
pill <- length(unique(data_allcontraception$ID[data_allcontraception$Contraception=='Pill']))
oth <-length(unique(data_allcontraception$ID[data_allcontraception$Contraception=='other']))

```

A-B contained 237 participants,
B-A contained 182 participant


we took out all non-natural contraception methods. these are the descriptives:

|  |
|:---|
|  **Natural:** `r nat`  |
| **Hor.Coil:** `r hor` |
| **Cop.Coil:** `r cop` |
| **Pill:**  `r pill` |
| **other:** `r oth` |



## TO DO


-doe figuren ook in VPN map



bij PSS:
-infographic Vanderhasselt COVID mental healt
-check of de vragen PSS zelfde zijn bij de norms voor corona zelfde vragen hebben gebruikt: zelfde soort PSS gebruikt? 

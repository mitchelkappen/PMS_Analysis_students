---
runtime: shiny
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# PMS Study {.tabset}

This is an interactive, Shiny Rmd file for the PMS study

```{r libraries, include = FALSE}

    
#### Settings & Packages #### -----------------------------------------------------
rm(list = ls())

#install packages
list_packages <- c("lme4", 'rsconnect','lmerTest','effects','dplyr', 'car', 'plyr', 'emmeans','fitdistrplus','ggplot2', 'ggstatsplot','ggsignif', 'ggformula','ggdist','ggpubr','ggeffects', 'gridExtra','tidyverse','pander','stringr','cowplot','lavaan','readr','jpeg','shiny','reshape2', 'yarrr','knitr' )
new_packages <- list_packages[!(list_packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)


library(lme4)
library(lmerTest)
library(effects)
library(dplyr)
library(plyr)
library(car)
library(emmeans)
library(fitdistrplus)
library(ggplot2)
library(ggstatsplot)
library(ggsignif)
library(ggformula)
library(ggdist)
library(ggpubr)
library(ggeffects)
library(gridExtra)
library(tidyverse)
library(pander)
library(stringr)
library(cowplot)
library(lavaan)
library(readr)
library(jpeg)
library(shiny)
library(reshape2)
library (yarrr)
library(knitr)
recode <- dplyr::recode
count <- dplyr::count 

# create folder to save figures
if (!dir.exists("figures")) dir.create("figures")


# General settings
nAGQ = 0 # When writing code, set to 0, when getting final results, set to 1
```


```{r load-data, echo=FALSE, results='asis'}
#### IMPORT data & INSPECTION #### -------------------------------------------------------------
knitr::opts_knit$set(root.dir = dirname(rstudioapi::getActiveDocumentContext()$path))# Set working directory to current directory
#data <-read.csv("C::/Downloads/allPMSdata.csv",header=TRUE)
#setwd("C::/Users/ASUSTeK/OneDrive/Documenten/GitHub/internship_sofie")
data <- read.csv("Data/allPMSdata.csv", header=TRUE)
#IMPORTANT! when not online it will go to Onedrive/documenten, so put Data/allPMS there as well
# data <- read.table("Data/allPMSdata.csv", header=TRUE)



data$Subject <- factor(data$ID)

levs<-union(data$ID, data$ID)
data$newid <- factor(data$ID, levels=levs, labels=seq_along(levs)) #this code replaces the '627, 534 IDs with 1, 2, 3, )



#we make a new variable that has value 1 for the first TestMoment and 2 for the second TestMoment
#These moments were counterbalanced
#when the order was B-A and the moment is B, this means it is the first test moment
#and vice versa for A-B and moment A. 

# TestMoment 1 == Follicular phase
# TestMoment 2 == Luteal phase
data$TestMoment[data$Order == "A-B" & data$Moment == "A"] = 1
data$TestMoment[data$Order == "B-A" & data$Moment == "A"] = 2
data$TestMoment[data$Order == "A-B" & data$Moment == "B"] = 2
data$TestMoment[data$Order == "B-A" & data$Moment == "B"] = 1
#check if there are still values missing (NA)
#sum(is.na(data$TestMoment))

# new variable PMSSCORE NEW iedereen pms 0 ook 0 iedereen die 1 OF 2 heeft wordt 1, 
data$PMSScoreNew[data$PMSScore==0] = 'noPMS'
data$PMSScoreNew[data$PMSScore==1] = 'PMS'
data$PMSScoreNew[data$PMSScore==2] = 'PMS' #PMDD, mr niet officiÃ«le diagnose dus gewoon PMS
#sum(is.na(data$PMSScoreNew))


# Check whether R recognizes the variable types correctly
#we make factors of the independable variables

data$PMSScore <- factor(data$PMSScore)
data$PMSScoreNew <- factor(data$PMSScoreNew)

data$Moment <- factor(data$TestMoment) # This removes "A and B", A == 1, B == 2 now

# Exclude data?
dataBig = data # Saved all the data here
data = data[, -which(names(data) == "X" | names(data) == "Stimulus" | names(data) == "Valence" | names(data) == "Arousal" | names(data) == "rt")] #removes these columns
data= distinct(data)

# exclude everyone on the pill/copper spiral/other: only those with Natural Contraception are left included
data<-subset(data, Contraception!="Pill" & Contraception!="other" & Contraception!="Cop. Coil" & Contraception!="Hor.Coil")

data <- subset(data,BSRI!=0 ) #remove datapoints where BSRI = 0

# Define the formula for the model & check which model fits the data best

data_temp <- data #to get back to

  # violin function

    geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                                 position = "dodge", trim = TRUE, scale = "area",
                                 show.legend = NA, inherit.aes = TRUE, ...) {
      layer(
      data = data,
      mapping = mapping,
      stat = stat,
      geom = GeomFlatViolin,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = list(
        trim = trim,
        scale = scale,
        ...
     )
    )
    }
GeomFlatViolin <-
  ggproto("GeomFlatViolin", Geom,
          setup_data = function(data, params) {
            data$width <- data$width %||%
              params$width %||% (resolution(data$x, FALSE) * 0.9)
            
            # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
            data %>%
              group_by(group) %>%
              mutate(ymin = min(y),
                     ymax = max(y),
                     xmin = x,
                     xmax = x + width / 2)
            
          },
          
          draw_group = function(data, panel_scales, coord) {
            # Find the points for the line to go all the way around
            data <- transform(data, xminv = x,
                              xmaxv = x + violinwidth * (xmax - x))
            
            # Make sure it's sorted properly to draw the outline
            newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),
                             plyr::arrange(transform(data, x = xmaxv), -y))
            
            # Close the polygon: set first and last point the same
            # Needed for coord_polar and such
            newdata <- rbind(newdata, newdata[1,])
            
            ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))
          },
          
          draw_key = draw_key_polygon,
          
          default_aes = aes(weight = 1, colour = "grey20", fill = "white", size = 0.5,
                            alpha = NA, linetype = "solid"),
          
          required_aes = c("x", "y")
)
    #standard error function
    standard_error <- function(x) sd(x)/sqrt(length(x))
    
    
    


```




## PMS, TestMoment, PSS and BSRI

* #### PMS: 
three groups originally: low and high PMS and what counts as ... on the questionnaire. 
These two last groups were taken together to form the 'no PMS' and 'PMS' groups

* #### TestMoment: 
there are two testmoments, 1 and 2. 1 stands for follicular phase, 2 for mid-luteal phase. 
these testmoments were counterbalanced across participants

!["Image Source: https://helloclue.com/articles/cycle-a-z/the-menstrual-cycle-more-than-just-the-period"](figures/MC.png){width=80%}

* #### PSS
Perceived Stress Scale


* #### BSRI:
Bem Sex Role Inventory
questionnaire with 2 subscales: 
1. masculinity
2. femininity
scores on 1_7 scale (4=middle)
above median score on both scales= 'androgynous'

https://www.psytoolkit.org/survey-library/sex-role-bem.html


### onderzoeksvraag: PMS vs noPMS op het gebied van:
- PSS
- BSRI
+ Interactie testmoment


```{r echo=FALSE}
ui<- fluidPage( # makes the User Interface
  sidebarPanel(
    selectInput("formula_choice", label="Choose a Formula:",
            choices= c('PSS ~ TestMoment', 'BSRI ~ TestMoment', 'PSS~ PMSScoreNew*TestMoment', 'BSRI ~PMSScoreNew*TestMoment'),
            selected='PSS ~ TestMoment'), # puts the choices in the first element which is accessed via input$formula_choice
  ),
  mainPanel(
     tabsetPanel(type = "tab",
                  tabPanel("pirateplot", plotOutput("pirateplot")),
                 tabPanel("raincloud", plotOutput("raincloud")),
                 tabPanel("raincloud2", plotOutput("raincloud2")),
                 tabPanel("AIC table", tableOutput("table")),
                 tabPanel("Anova", verbatimTextOutput("Anova")),
                 tabPanel("emmeans",verbatimTextOutput("emmeans")),
                 tabPanel("density",plotOutput("density"))
         )
  )
)

server <- function (input, output){ #we have to add this to the server
  
  
  output$pirateplot<- renderPlot({ 
      dpi=600    #pixels per square inch
    # jpeg(paste0(plotPrefix, "Figure", "_", plotTitles[i], ".jpeg"), width=8*dpi, height=4*dpi, res=dpi)
    par(mfcol = c(1, 1))
      pirateplot(
      formula= input$formula_choice,
      data=data,
      theme= 1,
      pal= "info",
      main= input$formula_choice,
      bean.f.o = .6, # Bean fill
      point.o = .3,  # Points
      inf.f.o = .7,  # Inference fill
      inf.b.o = .8,  # Inference border
      avg.line.o = 1,  # Average line
      bar.f.o = .5, # Bar
      inf.f.col = "white",  # Inf fill col
      inf.b.col = "black",  # Inf border col
      avg.line.col = "black",  # avg line col
      bar.f.col = gray(.8),  # bar filling color
      point.pch = 21,
      point.bg = "white",
      point.col = "black",
      point.cex = .7,
      xlab="",
    )

  })

  #https://wellcomeopenresearch.org/articles/4-63   some info on rainclouds
  output$raincloud <- renderPlot({
    if ((grepl("PSS", input$formula_choice))){
      p1 <- ggplot(data, aes(x = PMSScoreNew, y = PSS, fill=PMSScoreNew))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        geom_boxplot(width= .15, outlier.shape = NA)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        ylab('PSS')+xlab('PMSScoreNew')+coord_flip()+theme_cowplot()+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("distribution PSS in PMS vs no PMS")
      p1
    }else{
      p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill=PMSScoreNew))+
        geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
        ylab('BSRI')+xlab('PMSScoreNew')+coord_flip()+theme_cowplot()+
        geom_boxplot(width= .15, outlier.shape = NA)+
        geom_point(position=position_jitter(width=.15), size=.25)+
        theme(legend.position="none")+
        guides(fill=FALSE)+
        ggtitle("distribution BSRI in PMS vs no PMS")
      p2
    }
  })
  
  # https://www.rpubs.com/jenrichmond/W6LL  here some info on the following plot
    output$raincloud2 <- renderPlot({
      #function for weighted average
      x1 <- c(2, 4, 7)
      weighted_mean <- 0
      for (i in 1:length(x1)){
       weighted_mean <- (x1[i]+ x1[i+1] + x1[i+2])/3
       print (weighted_mean)
      }

      if ((grepl("PSS", input$formula_choice))){
        #dataframe for connected rainclouds
        dataf<- data
        head(dataf)
        # we create a dataframe with only PMSScoreNew and PSS
        require(reshape2)
        dataf<- melt(dataf, id=c("TestMoment", "PSS")) #takes out these 2 variables
        head(dataf)
        #sort by TestMoment ascending (so moment 2 is last)
        dataf <- dataf[order(dataf$TestMoment),]
        head(dataf)
        tail(dataf)
        df <-data_1x1(
          array_1= dataf$PSS[1:length(dataf$PSS)/2],
          array_2=dataf$PSS[(length(dataf$PSS)/2)+1:length(dataf$PSS)],
          jit_distance=0.09,
          jit_seed=321)
        raincloud_2<-raincloud_1x1_repmes(
          data= df,
          colors= (c('dodgerblue', 'darkorange')),
          fills= (c('dodgerblue', 'darkorange')),
          line_color="gray",
          line_alpha=.3,
          size=1,
          alpha= .6,
          align_clouds=FALSE
          )+
          scale_x_continuous (breaks=c(1,2), labels=c("1", "2"), limits=c(0,3))+
          xlab("TestMoment")+
          ylab("PSS")+
          theme_classic()
        raincloud_2
      } 
      else if ((grepl("BSRI", input$formula_choice))){
         #dataframe for connected rainclouds
        dataf<- data
        head(dataf)
        # we create a dataframe with only PMSScoreNew and PSS
        require(reshape2)
        dataf<- melt(dataf, id=c("TestMoment", "BSRI")) #takes out these 2 variables
        head(dataf)

        #sort by TestMoment ascending (so moment 2 is last)
        dataf <- dataf[order(dataf$TestMoment),]
        head(dataf)
        tail(dataf)
        df <-data_1x1(
          array_1= dataf$BSRI[1:length(dataf$BSRI)/2],
          array_2=dataf$BSRI[(length(dataf$BSRI)/2)+1:length(dataf$BSRI)],
          jit_distance=0.09,
          jit_seed=321)
        raincloud_2<-raincloud_1x1_repmes(
          data= df,
          colors= (c('dodgerblue', 'darkorange')),
          fills= (c('dodgerblue', 'darkorange')),
          line_color="gray",
          line_alpha=.3,
          size=1,
          alpha= .6,
          align_clouds=FALSE
          #ort='h'
          )+
          scale_x_continuous (breaks=c(1,2), labels=c("1", "2"), limits=c(0,3))+
          xlab("TestMoment")+
          ylab("BSRI")+
          theme_classic()
        raincloud_2
      }
      
    })
      

  output$table <- renderTable ({
    Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    modelNames= c('d0.1','d0.2','d0.3','d0.4','d0.5','d0.6','d0.7','d0.8','d0.9')
    tabel <-round(cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9)), digits=2)
    chosenModel = modelNames[which(tabel == min(tabel))]
    tabel <- data.frame(Models=c('chosen  Model:','d0.1','d0.2','d0.3','d0.4','d0.5','d0.6','d0.7','d0.8','d0.9'), AIC= c(cbind(chosenModel, tabel)))
    tabel
  })
  
  
  output$Anova <- renderPrint({
        Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
  
    modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
    tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
     chosenModel = modelNames[which(tabel == min(tabel))]
     Anova_1 <- Anova(chosenModel[[1]])
     cat(sprintf("\nAnova\n"))
     Anova_1
  })
  
  output$emmeans <- renderPrint({
            Formula <- paste0(input$formula_choice, ' + (1|Subject)')
    d0.1 <- lmer(Formula,data=data)
    d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)
    d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ)

    modelNames = c(d0.1,d0.2,d0.3,d0.4,d0.5,d0.6,d0.7,d0.8,d0.9)
    tabel <- cbind(AIC(d0.1), AIC(d0.2), AIC(d0.3), AIC(d0.4), AIC(d0.5), AIC(d0.6), AIC(d0.7), AIC(d0.8), AIC(d0.9))
    chosenModel = modelNames[which(tabel == min(tabel))]
    cat(sprintf("\n formula: %s\n", input$formula_choice))
    if ((grepl("PMS", input$formula_choice)==FALSE)){
      cat(sprintf("\n~ TestMoment\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ TestMoment, adjust ="fdr", type="response")
      print(Emm)
    }
    if (grepl("PMS", input$formula_choice)){
      cat(sprintf("\n~ PMS*TestMoment\n"))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
      print(Emm)
    }
  })
  
  
  output$density <- renderPlot({
      if ((grepl("PSS", input$formula_choice))){
      p1 <- ggplot(data, aes(x = PMSScoreNew, y = PSS, fill = PMSScoreNew)) +
        geom_flat_violin(aes(fill = PMSScoreNew),position = position_nudge(x = .2, y = 0), adjust = 1.5, trim = FALSE, alpha = .5, colour = NA)+
      geom_point(aes(x = as.numeric(PMSScoreNew)-.15, y = PSS, colour = PMSScoreNew),position = position_jitter(width = .05), size = .20, shape = 20)+
      geom_boxplot(aes(x = PMSScoreNew, y = PSS, fill = PMSScoreNew),outlier.shape = NA, alpha = .5, width = .1, colour = "black")+
      geom_point(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = mean(PSS), group = PMSScoreNew, colour = PMSScoreNew), shape = 18) +
      geom_errorbar(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = PSS, group = PMSScoreNew, colour = PMSScoreNew, ymin = mean(PSS)-standard_error(PSS), ymax = mean(PSS)+standard_error(PSS)), width = .10, length= .20)+
      scale_colour_brewer(palette = "Dark2")+
      scale_fill_brewer(palette = "Dark2")+
      ggtitle("Figure: Repeated Measures - Factorial (Extended)")
      p1
      
      } else {
      p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill = PMSScoreNew)) +
        geom_flat_violin(aes(fill = PMSScoreNew),position = position_nudge(x = .2, y = 0), adjust = 1.5, trim = FALSE, alpha = .5, colour = NA)+
      geom_point(aes(x = as.numeric(PMSScoreNew)-.15, y = BSRI, colour = PMSScoreNew),position = position_jitter(width = .05), size = .20, shape = 20)+
      geom_boxplot(aes(x = PMSScoreNew, y = BSRI, fill = PMSScoreNew),outlier.shape = NA, alpha = .5, width = .1, colour = "black")+
      geom_point(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = mean(BSRI), group = PMSScoreNew, colour = PMSScoreNew), shape = 18) +
      geom_errorbar(data = data, aes(x = as.numeric(PMSScoreNew)+.1, y = BSRI, group = PMSScoreNew, colour = PMSScoreNew, ymin = mean(BSRI)-standard_error(BSRI), ymax = mean(BSRI)+standard_error(BSRI)), width = .10, length= .20)+
      scale_colour_brewer(palette = "Dark2")+
      scale_fill_brewer(palette = "Dark2")+
      ggtitle("Figure: Repeated Measures - Factorial (Extended)")
      p2  
      }
  })

}
shinyApp(ui=ui, server=server)

```
we do (G)LMM: generalized linear mixed models
stress(PSS) or gender(BSRI) as dependable variable
PMS(2 levels) x TestMoment (2 levels)

AIC: Akaike Information Criterion: says which model best (lowest AIC) om beste fit model te vinden.

### conclusions

=> PSS is higher in testmoment 2: luteal phase
sign effect of PMS on PSS
no sign difference between testmoment 1 and 2 with the PMS group!


=>gender difference of PMS vs no PMS: PMS group more 'androgynous'
BSRI is higher in PMS than in noPMS group
-no effect of testmoment on BSRI


## DASS

* #### DASS-21_R
Depression Anxiety Stress Scale
DASS: 3 subschalen
DASS_Total, DASS_Stress, DASS_Anxiety, DASS_Depression
effect of PMS vs no PMSS
-geen interactie want het is trait: mr 1 afname
-wel interactie PSS: trait vs state?

#### onderzoeksvraag: PMS vs noPMS voor:
- DASS_alle subschalen
+interactie PSS



```{r echo=FALSE}

ui<- fluidPage( # makes the User Interface
  sidebarPanel(
    selectInput("formula_choice", label="Choose a Formula:",
            choices= c('DASS_Stress ~ PMSScoreNew', 'DASS_Anxiety ~ PMSScoreNew', 'DASS_Depression ~ PMSScoreNew'),
            selected='DASS_Stress ~ PMSScoreNew'), # puts the choices in the first element which is accessed via input$formula_choice
  ),
  mainPanel(
     tabsetPanel(type = "tab",
                  tabPanel("pirateplot", plotOutput("pirateplot")),
                  tabPanel("raincloud", plotOutput("raincloud")),
                 tabPanel("AIC table", tableOutput("table")),
                 tabPanel("Anova", verbatimTextOutput("Anova")),
                 tabPanel("emmeans",verbatimTextOutput("emmeans"))
         )))

server <- function (input, output){ #we have to add this to the server


  output$pirateplot<- renderPlot({
      dpi=600    #pixels per square inch
    par(mfcol = c(1, 1))
      pirateplot(
      formula= input$formula_choice,
      data=data,
      theme= 1,
      pal= "info",
      main= input$formula_choice,
      bean.f.o = .6, # Bean fill
      point.o = .3,  # Points
      inf.f.o = .7,  # Inference fill
      inf.b.o = .8,  # Inference border
      avg.line.o = 1,  # Average line
      bar.f.o = .5, # Bar
      inf.f.col = "white",  # Inf fill col
      inf.b.col = "black",  # Inf border col
      avg.line.col = "black",  # avg line col
      bar.f.col = gray(.8),  # bar filling color
      point.pch = 21,
      point.bg = "white",
      point.col = "black",
      point.cex = .7,
      xlab="",
    )
  })

  #https://wellcomeopenresearch.org/articles/4-63   some info on rainclouds
  #PMS vs noPMS over 2 fases Testmoment, https://github.com/jorvlan/raincloudplots
    output$raincloud <- renderPlot({
      if ((grepl("Stress", input$formula_choice))){
        p1 <- ggplot(data, aes(x = PMSScoreNew, y = PSS, fill=PMSScoreNew))+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          geom_boxplot(width= .15, outlier.shape = NA)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Stress in PMS vs no PMS")
        p1
      }else if ((grepl("Anxiety", input$formula_choice))){
        p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill=PMSScoreNew))+
          geom_boxplot(width= .15, outlier.shape = NA)+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Anxiety in PMS vs no PMS")
        p2
      }else {
        p2 <- ggplot(data, aes(x = PMSScoreNew, y = BSRI, fill=PMSScoreNew))+
          geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
          #geom_boxplot(width= .15, outlier.shape = NA)+
          geom_point(position=position_jitter(width=.15), size=.25)+
          ylab('Stress')+xlab('PMS')+coord_flip()+theme_cowplot()+
          theme(legend.position="none")+
          guides(fill=FALSE)+
          ggtitle("distribution Depression in PMS vs no PMS")
        p2
      }
    })

  output$table <- renderTable ({
    modelNames <- c()
    models <- c()
    #Formula <- 'DASS_Stress ~ PMSScoreNew + (1|Subject)'
    Formula <- paste0(input$formula_choice, '+ (1|Subject)')
    tryCatch(
      { d0.1 <- lmer(Formula,data=data); # if this formula works
      models <- c(models, d0.1) #we add this
      modelNames <- c(modelNames, 'd0.1')}, 
      error=function(e){})
    tryCatch(
      { d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.2) 
      modelNames <- c(modelNames, 'd0.2')}, 
      error=function(e){})
    tryCatch(
      { d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.3)
      modelNames <- c(modelNames, 'd0.3')}, 
      error=function(e){})
    tryCatch(
      { d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.4)
      modelNames <- c(modelNames, 'd0.4')}, 
      error=function(e){})
    tryCatch(
      { d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.5) 
      modelNames <- c(modelNames, 'd0.5')}, 
      error=function(e){})
    tryCatch(
      { d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.6) 
      modelNames <- c(modelNames, 'd0.6')}, 
      error=function(e){})
    tryCatch(
      { d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
      models <- c(models, d0.7) 
      modelNames <- c(modelNames, 'd0.7')}, 
      error=function(e){})
    tryCatch(
      { d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.8) 
      modelNames <- c(modelNames, 'd0.8')}, 
      error=function(e){})
    tryCatch(
      { d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.9) 
      modelNames <- c(modelNames, 'd0.9')}, 
      error=function(e){})
    tabel <- c()
    for (i in 1:length(models)){
      AIC<- AIC(models[[i]])
      print(AIC)
      tabel <- c(tabel,round(AIC))}
    chosenModel = modelNames[which(tabel == min(tabel))]
    tabel <- data.frame(Models=c('chosen  Model:', modelNames), AIC= c(chosenModel, tabel))
    tabel
  })

  output$Anova <- renderPrint({
    models <-c()
        Formula <- paste0(input$formula_choice, ' + (1|Subject)')
         tryCatch(
      { d0.1 <- lmer(Formula,data=data);
      models <- c(models, d0.1)}, 
      error=function(e){})
    tryCatch(
      { d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.2)}, 
      error=function(e){})
    tryCatch(
      { d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.3)}, 
      error=function(e){})
    tryCatch(
      { d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.4)}, 
      error=function(e){})
    tryCatch(
      { d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.5)}, 
      error=function(e){})
    tryCatch(
      { d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.6)}, 
      error=function(e){})
    tryCatch(
      { d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
      models <- c(models, d0.7)}, 
      error=function(e){})
    tryCatch(
      { d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.8)}, 
      error=function(e){})
    tryCatch(
      { d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.9)}, 
      error=function(e){})
    tabel <- c()
    for (i in 1:length(models)){
      AIC<- AIC(models[[i]])
      tabel <- c(tabel,round(AIC))}
    chosenModel = models[which(tabel == min(tabel))]
   Anova_1 <- Anova(chosenModel[[1]])
   cat(sprintf("\nAnova of %s\n", input$formula_choice))
   Anova_1

})

  output$emmeans <- renderPrint({
    models <-c()
        Formula <- paste0(input$formula_choice, ' + (1|Subject)')
         tryCatch(
      { d0.1 <- lmer(Formula,data=data);
      models <- c(models, d0.1)}, 
      error=function(e){})
    tryCatch(
      { d0.2 <- glmer(Formula,data=data, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.2)}, 
      error=function(e){})
    tryCatch(
      { d0.3 <- glmer(Formula,data=data, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.3)}, 
      error=function(e){})
    tryCatch(
      { d0.4 <- glmer(Formula,data=data, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.4)}, 
      error=function(e){})
    tryCatch(
      { d0.5 <- glmer(Formula,data=data, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.5)}, 
      error=function(e){})
    tryCatch(
      { d0.6 <- glmer(Formula,data=data, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.6)}, 
      error=function(e){})
    tryCatch(
      { d0.7 <- glmer(Formula,data=data, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
      models <- c(models, d0.7)}, 
      error=function(e){})
    tryCatch(
      { d0.8 <- glmer(Formula,data=data, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.8)}, 
      error=function(e){})
    tryCatch(
      { d0.9 <- glmer(Formula,data=data, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ); 
      models <- c(models, d0.9)}, 
      error=function(e){})
    tabel <- c()
    for (i in 1:length(models)){
      AIC<- AIC(models[[i]])
      tabel <- c(tabel,round(AIC))}
    chosenModel = models[which(tabel == min(tabel))]

    if ((grepl("PSS", input$formula_choice)==FALSE)){
      cat(sprintf("\nemmeans of formula: %s\n", input$formula_choice))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew, adjust ="fdr", type="response")
      print(Emm)
    }
    else{
      cat(sprintf("\nemmeans of formula: %s\n", input$formula_choice))
      Emm <- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*PSS, adjust ="fdr", type="response")
      print(Emm)
    }
  })

}


shinyApp(ui=ui, server=server)

```

### Conclusions
* sign more stress PMS than no PMS
* sign more anxiety PMS than no 
* sign more depression PMS than no PMS


## Stimuli

These were images that were either negative, positive or neutral. 
22 matched images (e.g. in TestMoment 1 image of needle in arm, in TestMoment 2 needle in leg. or image puppy and image of another puppy)

participants could indicate how the images scored for them on valence and arousal

```{r echo=FALSE}

# unique<-sort(unique(dataBig$Stimulus), decreasing=FALSE) #find all the stimuli
# we maken een density plotvoor zowel valence als arousal voor elke stimulus (2x22)
ui<- fluidPage( 
  sidebarPanel(
    radioButtons("stimulus", label="Choose a Stimulus:",
            choices= c('1440', '1463', '1610', '1710', '1722', '1750', '2057', '2070', '2160', '2165', '2340', '2360', '2800', '3261', '4180', '4290', '4490', '4531',  '4550', '4561', '4658', '5030', '5600', '5800', '5982', '6312', '6313', '7182', '7211', '7224', '7238', '7380', '7480', '7481', '9220', '9300', '9320', '9584', '9592', '9594', '9600', '9911', '9920', '9921'), inline=TRUE,
            selected='1440'), ),
  mainPanel(
    tabsetPanel(type = "tab",
      tabPanel("densityplot", plotOutput("densityplot")),
      tabPanel("IAPs_Image", plotOutput("IAPs_Image"))
    )
  )
)

server <- function (input, output){ 
  #we make a density plot of valence/arousal per stimulus.
  output$densityplot<- renderPlot({
    d<-melt(data.frame(valence=c(dataBig$Valence[dataBig$Stimulus==input$stimulus]),arousal=c(dataBig$Arousal[dataBig$Stimulus==input$stimulus])))
    
    pirateplot(
      formula=value~variable,
      data=d,
      main= input$stimulus
    )
  })
  
  output$IAPs_Image <- renderImage({
    list(src=str_glue("Z:/shares/ghep_lab/ImageDatabases/IAPS/{input$stimulus}.jpg"),
         filetype="image/jpeg",
         width=400,
         height=300
         )
  })
}



#look at outliers, remove them, plot again! 


shinyApp(ui=ui, server=server)




```


 positive stimuli

'medium'= 40-60

|  |  |
|:----|:----------------------|
|  **high valence, high arousal:** | 4658, 4561, 4658  |
| **high valence, low arousal:** |  2360, 5030, 5600, 5800, 5982, 5030, 5800, 5982 |
| **high valence, medium arousal:** | 1440, 1463, 1610, 1710, 1722, 1750, 2057, 2070, 2160, 2165, 2340 7480, 7481, 5600, 7480, 7481 |
| **low valence, high arousal:** | 2800, 3261, 6312, 6313, 7182, 7380, 6312, 6313, 7380, 9600, 9911, 9920, 9921 |
| **low valence, low arousal:** |  9220 |
| **low valence, medium arousal:** | 9300, 9320, 9584, 9592, 9594 |
| **medium valence, high arousal:** | 7182 |
| **medium valence, low arousal:** |  7224, 7224 |
| **medium valence, medium arousal:** |  7211, 7238, 4550, 7211, 7238 |


when Medium, arousal tends to be normally distributed
However: we often find 2 gauss curves on top of each other
same for valence: more of a gaussian curve when middle, more of a cup when towards the extreme.

we sometimes see some interesting outliers e.g. 1463,2057,4658, 7481, 9600: most score this high valence, high arousal but some don't! opposite response
=> interesting: see if the same persons who respond 'atypical' to these images? Perhaps misunderstanding the scales or big horror fans/ puppy haters? 

=> index de top eruit


## reaction times

```{r echo=FALSE}
#plot reaction times with raincloudplot

dataBig_out<-dataBig #the dataBig with the rt outliers
d_out<-melt(data.frame(rt=c(dataBig_out$rt))) # we melt to wide format
p1 <- ggplot(d_out, aes(x = variable, y = value, fill=variable))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
  ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
  geom_point(position=position_jitter(width=.15), size=2)+
  geom_boxplot(width= .10, outlier.shape = NA)+
  theme(legend.position="none")+
  ggtitle("reaction times with outliers")
p1

summary(dataBig_out$rt)

dataBig <- subset(dataBig, rt < 25000)
d<-melt(data.frame(rt=c(dataBig$rt)))
p3 <- ggplot(d, aes(x = variable, y = value, fill=variable))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
  geom_point(position=position_jitter(width=.15), size=0.25)+
  ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
  geom_boxplot(width= .10, outlier.shape = NA)+
  theme(legend.position="none")+
  guides(fill=FALSE)+
  ggtitle("reaction times < 25 000")
p3

dataBig <- subset(dataBig, rt < 15000)
d<-melt(data.frame(rt=c(dataBig$rt)))
p4 <- ggplot(d, aes(x = variable, y = value, fill=variable))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
  geom_point(position=position_jitter(width=.15), size=0.25)+
  ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
  geom_boxplot(width= .10, outlier.shape = NA)+
  theme(legend.position="none")+
  guides(fill=FALSE)+
  ggtitle("reaction times < 15 000")
p4

print('some summary info')
summary(dataBig$rt)

#outlier removal method 2
lower_bound <- quantile (dataBig$rt, 0.025)
print('0.025 lower bound')
lower_bound
upper_bound <- quantile (dataBig$rt, 0.975)
print('0.975 upper bound')
upper_bound

dataBig <- subset(dataBig, rt < 12939)
d<-melt(data.frame(rt=c(dataBig$rt)))
p5 <- ggplot(d, aes(x = variable, y = value, fill=variable))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
  geom_point(position=position_jitter(width=.15), size=0.25)+
  ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
  geom_boxplot(width= .10, outlier.shape = NA)+
  theme(legend.position="none")+
  guides(fill=FALSE)+
  ggtitle("reaction times < 12 939 (0.975 upper bound)")
p5

out<-boxplot.stats(dataBig$rt)$out#outliers
out_ind<-which(dataBig$rt %in% c(out))#row numbers that contain outliers
boxplot(dataBig$rt, ylab='rt') #boxplot
mtext(paste('boxplot with outliers')) #boxplot with outliers


dataBig <- dataBig%>%slice(out_ind)
d<-melt(data.frame(rt=c(dataBig$rt)))
p5 <- ggplot(d, aes(x = variable, y = value, fill=variable))+
  geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
  geom_point(position=position_jitter(width=.15), size=0.7)+
  ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
  geom_boxplot(width= .10, outlier.shape = NA)+
  theme(legend.position="none")+
  guides(fill=FALSE)+
  ggtitle("reaction times without outliers")
p5

out<-boxplot.stats(dataBig$rt)$out#outliers
boxplot(dataBig$rt, ylab='rt') #boxplot
mtext(paste('boxplot without outliers',paste(round(out),collapse=','))) #boxplot with outliers


runApp(paste0(dirname(rstudioapi::getActiveDocumentContext()$path)),
       display.mode='showcase')

```


## Hyptothesen en onderzoeksvragen:



### Voor de stimuli 
#### Eerste stap:
- Bekijken Valence en arousal tussen de groepen en testmomenten, over alle stimuli als een geheel

dikke outliers bekijken
we willen normaalverdeling bv blije stimulus
Mr: gezien hypothese dat verdeling diksmaldiksmal: 2 groepen. en paar rare outliers? droevig van kitten (sanity check)

#### Next:
- Per stimulus gemiddelden plotten
-- Om erachter te komen of er coherent geantwoord wordt
-- Om te zien of ze niet te veel van elkaar afwijken
--- waarchuwing; ze gaan veel van elkaar afwijken. 

gemm reactie per participant bekijken: over alle stimuli gemm valence, gemm arousal en standaarddev
plotten gemm tussen groupen op stimuli
pas erna onderverdelen in stimuligroepen




### Overig:
Normgroepen opzoeken voor PSS bij (jonge) vrouwen
https://www.cambridge.org/core/journals/spanish-journal-of-psychology/article/abs/perceived-stress-scale-pss-normative-data-and-factor-structure-for-a-largescale-sample-in-mexico/752B62D15A932A2D148D04376E949F67

https://bmcpsychiatry.biomedcentral.com/articles/10.1186/s12888-016-0875-9/tables/6


###TO DO:


-variabelen steekproef in beeld (puur omdat  interessant: PMS vs no PMS: leeftijd, duur cyclus (gemm))

-stimuli plotten, outliers eruit 

maak shiny appp
https://shiny.rstudio.com/articles/display-modes.html
